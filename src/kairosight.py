#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import math
import os
import sys
import time
import numpy
from pathlib import Path, PurePath
from random import random
from util.preparation import open_stack
from ui.KairoSight_WindowMDI import Ui_WindowMDI
from ui.KairoSight_WindowMain import Ui_WindowMain
from PyQt5.QtWidgets import QApplication, QWidget, QMainWindow, QFileDialog
from PyQt5.QtGui import QColor


class WindowMDI(QMainWindow, Ui_WindowMDI):
    """Customization for Ui_MDIMainWindow, and MDI main window"""

    def __init__(self, parent=None):
        # initialization of the superclass
        super(WindowMDI, self).__init__(parent)
        # setup the GUI --> function generated by pyuic5
        self.setupUi(self)
        self.raise_()
        # connect the signals with the slots
        # self.actionLoad.triggered.connect(self.open_tiff)
        # self.actionClose.triggered.connect(self.close)
        self.actionTIFF.triggered.connect(self.open_tiff)

    def open_tiff(self, file=None):
        """Open a WindowMain with a TIFF stack within the MDI area"""
        if file:
            print('Opening tiff with passed filepath: ' + file)
        else:
            # Use a QFileDialog to get filepath if none provided
            file, mask = QFileDialog.getOpenFileName(self, 'Open a .tif/.tiff stack')

        if file:
            self.status_print('Opening ' + file + ' ...')
            f_purepath = PurePath(file)
            f_ext = f_purepath.suffix
            if f_ext == '.pcoraw':
                # Change .pcoraw files to .tif?
                # os.rename(file, f_name + '.tif')
                p = Path(file)
                p.rename(p.with_suffix('.tif'))
                print('* .pcoraw covnerted to a .tif')
                # Use a QFileDialog to get the new filepath
                file, mask = QFileDialog.getOpenFileName(self, 'Open a .tif/.tiff stack')
                self.status_print('Opening ' + file + ' ...')
                f_purepath = PurePath(file)

            f_string = str(f_purepath)
            f_display = str(f_purepath.parent) + '\\' + '\t' + f_purepath.stem + ' ' + f_purepath.suffix
            print('file (path name ext): ' + f_display)
            try:
                # Create QMdiSubWindow with Ui_WidgetTiff
                sub = WindowMain(parent=self, file_purepath=f_purepath)
                sub.setObjectName(str(file))
                sub.setWindowTitle('TIFF View: ' + f_display)
                # Add and connect QMdiSubWindow to MDI
                self.mdiArea.addSubWindow(sub)
                sub.show()
                self.statusBar().showMessage('Opened ' + file)
            except:
                exc_type, exc_value = sys.exc_info()[:2]
                self.status_print(' ! ' + str(exc_type) + ' : ' + str(exc_value))
        else:
            print('path is None')
            self.statusBar().showMessage('Open cancelled')

    def status_print(self, text):
        self.statusBar().showMessage(text)


class WindowMain(QWidget, Ui_WindowMain):
    """Customization for Ui_WindowMain"""

    def __init__(self, parent=None, file_purepath=None):
        super(WindowMain, self).__init__(parent)  # initialization of the superclass
        self.setupUi(self)  # setup the UI
        self.next_buttons = []
        self.setup_next_buttons()
        self.skip_checkboxes = []
        self.setup_skip_buttons()
        self.properties = {'fps': 0.0, 'scale': 0.0, 'type': None, 'subject': None}

        # Customize Feedback Text
        self.textBrowser_Feedback.setStyleSheet('background: rgb(10, 10, 10)')

        # Import file for this window
        self.file_purepath = file_purepath
        self.file_path_string = str(file_purepath)
        self.project_purepath = str(file_purepath.parent) + '\\' + str(file_purepath.stem) + '_ks_project'
        self.video_data, self.stack_real_meta = open_stack(source=self.file_path_string)
        # Flip each frame along the Y-axis (up/down)
        self.frame_n = self.video_data.shape[0]
        for i in range(self.frame_n):
            self.video_data[i] = numpy.flipud(self.video_data[i])
        self.width, self.height = self.video_data.shape[2], self.video_data.shape[1]

        # If needed, create KairoSight project folder
        try:
            os.mkdir(self.project_purepath)
        except FileExistsError:
            self.feedback_action('Project folder already exists : \\' +
                                 str(file_purepath.stem) + '_ks_project\\', success=True)

        # Setup and connect UI components
        self.horizontalScrollBar.valueChanged['int'].connect(self.update_video)
        self.horizontalScrollBar.setMinimum(1)
        self.horizontalScrollBar.setMaximum(self.frame_n)
        self.lcdNumber_frame_n.display(self.frame_n)
        self.graphicsView.p1.setAspectLocked(True)

        # Set histogram to image levels and use a manual range
        self.graphicsView.histogram.setLevels(self.video_data.min(), self.video_data.max())
        self.graphicsView.histogram.setHistogramRange(self.video_data.min(), self.video_data.max())

    def update_video(self, frame=0):
        """Updates the video frame drawn to the canvas"""
        # Update ImageItem(s) with a frame in a stack
        self.graphicsView.img_item.setImage(self.video_data[frame - 1, ...])
        # Notify histogram items of image change
        self.graphicsView.histogram.regionChanged()

    def update_properties(self, step_name):
        try:
            self.properties['fps'] = float(self.frameRateLineEdit.text())
        except ValueError:
            self.feedback_action('Preparation step {} ERROR : Bad entry in "Frame Rate (fps)",'
                                 ' must be a number (e.g 505.5)'.format(step_name), success=False)
            raise ValueError
        try:
            self.properties['scale'] = float(self.scaleLineEdit.text())
        except ValueError:
            self.feedback_action('Preparation step {} ERROR : Bad entry in "Scale (px/cm)",'
                                 ' must be a number (e.g 101.4362)'.format(step_name), success=False)
            raise ValueError

    def apply_prep_step(self, step_button):
        step_name = step_button.accessibleName()
        try:
            if step_button is self.buttonNextPrep_Props:
                self.update_properties(step_name)
        except ValueError:
            self.reset_progress(step_button)
        except:
            self.reset_progress(step_button)
            exc_type, exc_value = sys.exc_info()[:2]
            real_error = str(exc_type) + ' : ' + str(exc_value)
            self.feedback_action('Preparation step {} ERROR : {}'.format(step_name, real_error), success=False)
        else:
            self.step_proceed(step_button)
            self.feedback_action('Preparation step {} PASSED'.format(step_name), success=True)
            if step_button is self.buttonNextPrep_Mask:
                self.feedback_action('Preparation STAGE PASSED', success=True)

    def apply_proc_step(self, step_button):
        step_success = True and (random() > 0.5)
        step_name = step_button.accessibleName()
        if step_success:
            self.step_proceed(step_button)
            self.feedback_action('Processing step {} PASSED'.format(step_name), success=step_success)
            if step_button is self.buttonNextProc_SNR:
                self.feedback_action('Processing STAGE PASSED', success=step_success)
        else:
            self.reset_progress(step_button)
            test_error = ' random chance'
            self.feedback_action('Processing step {} ERROR : {}'
                                 .format(step_name, test_error), success=step_success)

    def apply_analysis_step(self, step_button):
        step_success = True and (random() > 0.5)
        step_name = step_button.accessibleName()
        if step_success:
            self.step_proceed(step_button)
            self.feedback_action('Analysis step {} PASSED'.format(step_name), success=step_success)
            if step_button is self.buttonNextAnalysis_Analyze:
                self.feedback_action('Analysis STAGE PASSED', success=step_success)
        else:
            self.reset_progress(step_button)
            test_error = ' random chance'
            self.feedback_action('Analysis step {} ERROR : {}'
                                 .format(step_name, test_error), success=step_success)

    def skip_prep_step(self, step_checkbox, step_button):
        step_name = step_button.accessibleName()
        if step_checkbox.checkState():
            self.step_proceed(step_button)
            step_button.setEnabled(False)
            self.feedback_action('Preparation step {} SKIPPED'.format(step_name), success=True)
            if step_button is self.buttonNextPrep_Mask:
                self.feedback_action('Preparation STAGE PASSED', success=True)
        else:
            self.reset_progress(step_button)

    def skip_proc_step(self, step_checkbox, step_button):
        step_name = step_button.accessibleName()
        if step_checkbox.checkState():
            self.step_proceed(step_button)
            step_button.setEnabled(False)
            self.feedback_action('Processing step {} SKIPPED'.format(step_name), success=True)
            if step_button is self.buttonNextProc_SNR:
                self.feedback_action('Processing STAGE PASSED', success=True)
        else:
            self.reset_progress(step_button)

    def skip_analysis_step(self, step_checkbox, step_button):
        step_name = step_button.accessibleName()
        if step_checkbox.checkState():
            self.step_proceed(step_button)
            step_button.setEnabled(False)
            self.feedback_action('Analysis step {} SKIPPED'.format(step_name), success=True)
        else:
            self.reset_progress(step_button)

    def feedback_action(self, action_text, success=False):
        time_tuple = time.localtime()
        time_string = '(' + time.strftime("%H:%M:%S", time_tuple) + ') '
        if success:
            self.textBrowser_Feedback.setTextColor(QColor(5, 230, 5))  # green text
        else:
            self.textBrowser_Feedback.setTextColor(QColor(230, 5, 5))  # red text
        self.textBrowser_Feedback.append(time_string + action_text)

    def setup_next_buttons(self):
        self.next_buttons = [self.buttonNextPrep_Props, self.buttonNextPrep_Crop, self.buttonNextPrep_Mask,
                             self.buttonNextProc_Norm, self.buttonNextProc_Filter, self.buttonNextProc_SNR,
                             self.buttonNextAnalysis_Isolate, self.buttonNextAnalysis_Analyze]
        self.buttonNextPrep_Props.released \
            .connect(lambda: self.apply_prep_step(self.buttonNextPrep_Props))
        self.buttonNextPrep_Crop.released \
            .connect(lambda: self.apply_prep_step(self.buttonNextPrep_Crop))
        self.buttonNextPrep_Mask.released \
            .connect(lambda: self.apply_prep_step(self.buttonNextPrep_Mask))
        self.buttonNextProc_Norm.released \
            .connect(lambda: self.apply_proc_step(self.buttonNextProc_Norm))
        self.buttonNextProc_Filter.released \
            .connect(lambda: self.apply_proc_step(self.buttonNextProc_Filter))
        self.buttonNextProc_SNR.released \
            .connect(lambda: self.apply_proc_step(self.buttonNextProc_SNR))
        self.buttonNextAnalysis_Isolate.released \
            .connect(lambda: self.apply_analysis_step(self.buttonNextAnalysis_Isolate))
        self.buttonNextAnalysis_Analyze.released \
            .connect(lambda: self.apply_analysis_step(self.buttonNextAnalysis_Analyze))

    def setup_skip_buttons(self):
        self.skip_checkboxes = [self.checkBoxSkipPrep_Crop.stateChanged, self.checkBoxSkipPrep_Mask.stateChanged,
                                self.checkBoxSkipProc_Filter.stateChanged, self.checkBoxSkipProc_SNR.stateChanged,
                                self.checkBoxSkipAnalysis_Isolate.stateChanged]
        self.checkBoxSkipPrep_Crop.stateChanged \
            .connect(lambda: self.skip_prep_step(self.checkBoxSkipPrep_Crop, self.buttonNextPrep_Crop))
        self.checkBoxSkipPrep_Mask.stateChanged \
            .connect(lambda: self.skip_prep_step(self.checkBoxSkipPrep_Mask, self.buttonNextPrep_Mask))
        self.checkBoxSkipProc_Filter.stateChanged \
            .connect(lambda: self.skip_proc_step(self.checkBoxSkipProc_Filter, self.buttonNextProc_Filter))
        self.checkBoxSkipProc_SNR.stateChanged \
            .connect(lambda: self.skip_proc_step(self.checkBoxSkipProc_SNR, self.buttonNextProc_SNR))
        self.checkBoxSkipAnalysis_Isolate.stateChanged \
            .connect(lambda: self.skip_analysis_step(self.checkBoxSkipAnalysis_Isolate,
                                                     self.buttonNextAnalysis_Isolate))

    def step_proceed(self, step_button):
        i = 1
        while self.next_buttons[i - 1] is not step_button:
            i += 1
        if i < len(self.next_buttons):
            self.reset_progress(self.next_buttons[i])

    def reset_progress(self, step_button):
        i = 1
        step_button.setEnabled(True)
        if step_button is self.buttonNextPrep_Crop:
            self.checkBoxSkipPrep_Crop.setEnabled(True)
            self.checkBoxSkipPrep_Crop.setChecked(False)
        elif step_button is self.buttonNextPrep_Mask:
            self.checkBoxSkipPrep_Mask.setEnabled(True)
            self.checkBoxSkipPrep_Mask.setChecked(False)
        elif step_button is self.buttonNextProc_Filter:
            self.checkBoxSkipProc_Filter.setEnabled(True)
            self.checkBoxSkipProc_Filter.setChecked(False)
        elif step_button is self.buttonNextProc_SNR:
            self.checkBoxSkipProc_SNR.setEnabled(True)
            self.checkBoxSkipProc_SNR.setChecked(False)
        elif step_button is self.buttonNextAnalysis_Isolate:
            self.checkBoxSkipAnalysis_Isolate.setEnabled(True)
            self.checkBoxSkipAnalysis_Isolate.setChecked(False)
        while self.next_buttons[i - 1] is not step_button:
            i += 1
        while i < len(self.next_buttons):
            cur_button = self.next_buttons[i]
            if not cur_button.isEnabled():
                break
            if cur_button is self.buttonNextPrep_Crop:
                self.checkBoxSkipPrep_Crop.setEnabled(False)
            elif cur_button is self.buttonNextPrep_Mask:
                self.checkBoxSkipPrep_Mask.setEnabled(False)
            elif cur_button is self.buttonNextProc_Filter:
                self.checkBoxSkipProc_Filter.setEnabled(False)
            elif cur_button is self.buttonNextProc_SNR:
                self.checkBoxSkipProc_SNR.setEnabled(False)
            elif cur_button is self.buttonNextAnalysis_Isolate:
                self.checkBoxSkipAnalysis_Isolate.setEnabled(False)
            cur_button.setEnabled(False)
            i += 1


if __name__ == '__main__':
    # create the GUI application
    app = QApplication(sys.argv)
    # instantiate and show the main window
    ks_mdi = WindowMDI()
    ks_mdi.show()
    # start the Qt main loop execution, exiting from this script
    # with the same return code as the Qt application
    sys.exit(app.exec_())
