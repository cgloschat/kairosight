#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import sys
import traceback
import numpy as np
import pandas as pd
from pathlib import PurePath

import scipy.signal as sig
from PyQt5 import QtCore
from PyQt5.QtCore import QDir, Qt
from PyQt5.QtGui import QStandardItemModel
from PyQt5.QtWidgets import QApplication, QWidget, QMainWindow, QFileDialog, QFileSystemModel, QDialogButtonBox, \
    QTableWidgetItem
import pyqtgraph as pg
from ui.KairoSightMainMDI import Ui_MDIMainWindow
from ui.KairoSightWidgetTIFFpyqtgraph import Ui_WidgetTiff
from ui.KairoSightWidgetFolderTree import Ui_WidgetFolderTree
from ui.KairoSightWidgetIsolate import Ui_WidgetIsolate
from ui.KairoSightWidgetAnalyze import Ui_WidgetAnalyze
from ui.KairoSightWidgetExport import Ui_WidgetExport
from algorithms import tifopen, peak_detect, process


# TODO review/remove/reformat print statements

class DesignerMainWindow(QMainWindow, Ui_MDIMainWindow):
    """Customization for Ui_MDIMainWindow, and MDI main window"""
    # TODO add Export to csv (study, file, roi, ...)
    # TODO change MainWindow's subwindow creation methods to "Window..."

    def __init__(self, parent=None):
        # initialization of the superclass
        super(DesignerMainWindow, self).__init__(parent)
        # setup the GUI --> function generated by pyuic5
        self.setupUi(self)
        # connect the signals with the slots
        # self.actionLoad.triggered.connect(self.open_tiff)
        # self.actionClose.triggered.connect(self.close)
        self.actionTIFF.triggered.connect(self.open_tiff)
        self.actionFolder.triggered.connect(self.open_folder)
        self.actionStart_Isolate.triggered.connect(self.isolate)
        self.actionStart_Analyze.triggered.connect(self.analyze)
        # self.actionStart_Export.triggered.connect(self.export)
        self.menuExport.aboutToShow.connect(self.export)

    def open_tiff(self, file=None):
        """Open a SubWindow with a TIFF stack in the main MDI area"""
        if file:
            print('Opening tiff with passed filepath: ' + file)
        else:
            # Use a QFileDialog to get filepath if none provided
            file, mask = QFileDialog.getOpenFileName(self, 'Open a .tif/.tiff stack')

        if file:
            self.statusBar().showMessage('Opening ' + file + ' ...')
            f_purepath = PurePath(file)
            f_path = str(f_purepath.parent) + '/'
            f_name = f_purepath.stem
            f_ext = f_purepath.suffix
            f_display = f_path + ' ' + f_name + ' ' + f_ext
            print('file (path name ext): ' + f_display)
            if f_ext is '.tif' or '.tiff':
                # print('TIFF chosen')
                # Create QMdiSubWindow with Ui_WidgetTiff
                try:
                    sub = DesignerSubWindowTiff(parent=self, f_path=f_path, f_name=f_name, f_ext=f_ext)
                    # print('DesignerSubWindowTiff "sub" created')
                    sub.setObjectName(str(file))
                    sub.setWindowTitle('TIFF View: ' + f_display)
                    # Add and connect QMdiSubWindow to MDI
                    self.mdiArea.addSubWindow(sub)
                    # print('"sub" added to MDI')
                    sub.show()
                    self.statusBar().showMessage('Opened ' + file)
                except Exception:
                    traceback.print_exc()
                    ex_type, ex_value, ex_traceback = sys.exc_info()
                    self.statusBar().showMessage('Failed to open, ' + file + ' : ' + str(ex_type))
        else:
            print('path is None')
            self.statusBar().showMessage('Open cancelled')

    def open_folder(self):
        """Open a SubWindow with a folder tree view in the main MDI area"""
        folder_path = QFileDialog.getExistingDirectory(self, 'Choose a folder to view')
        print('Folder chosen! path: ' + folder_path)
        # Create QMdiSubWindow with Ui_WidgetTiff
        sub = DesignerSubWindowFolder(parent=self, root=folder_path)
        print('DesignerSubWindowFolder "sub" created')
        print('Set "sub" widget to "Ui_WidgetFolderTree"')
        sub.setWindowTitle('Folder View: ' + folder_path)
        # Add and connect QMdiSubWindow to MDI
        self.mdiArea.addSubWindow(sub)
        sub.pushButtonOpen.released.connect(lambda: self.open_tiff(sub.currentFilePath))
        print('"sub" added to MDI')
        sub.show()

    def isolate(self):
        """Open the Isolate SubWindow"""
        tiff_windows = []
        # Create a list of all open TIFF subwindows
        for sub in self.mdiArea.subWindowList():
            # print('**' + str(type(sub.widget())) + ', ' + sub.widget().objectName() + ' is a tiff? ')
            if type(sub.widget()) is DesignerSubWindowTiff:
                tiff_windows.append(sub)
        if tiff_windows:
            sub_iso = DesignerSubWindowIsolate(parent=self, w_list=tiff_windows)
            self.mdiArea.addSubWindow(sub_iso)
            sub_iso.show()
        else:
            self.statusBar().showMessage('No processed videos to isolate!')

    def analyze(self):
        """Open the Analyze SubWindow"""
        tiff_windows = []
        # Create a list of all open TIFF subwindows
        for sub in self.mdiArea.subWindowList():
            # print('**' + str(type(sub.widget())) + ', ' + sub.widget().objectName() + ' is a tiff? ')
            if type(sub.widget()) is DesignerSubWindowTiff:
                if sub.widget().ROIs:
                    tiff_windows.append(sub)
        if tiff_windows:
            sub_analyze = DesignerSubWindowAnalyze(parent=self, w_list=tiff_windows)
            self.mdiArea.addSubWindow(sub_analyze)
            sub_analyze.show()
        else:
            self.statusBar().showMessage('No processed videos with ROIs to analyze!')

    def export(self):
        """Open a dialog to copy or export .csv of Analysis results"""
        # df.to_csv('myDataFrame.csv')
        tiff_windows = []
        # Create a list of all open TIFF subwindows
        for sub in self.mdiArea.subWindowList():
            # print('**' + str(type(sub.widget())) + ', ' + sub.widget().objectName() + ' is a tiff? ')
            if type(sub.widget()) is DesignerSubWindowTiff:
                # if sub.widget().ROIs:
                tiff_windows.append(sub)
        if tiff_windows:
            sub_export = DesignerSubWindowExport(w_list=tiff_windows)
            self.mdiArea.addSubWindow(sub_export)
            sub_export.show()
        else:
            self.statusBar().showMessage('No analyzed ROIs with results to export!')


class DesignerSubWindowTiff(QWidget, Ui_WidgetTiff):
    """Customization for Ui_WidgetTiff subwindow for an MDI"""
    # TODO split and overlay videos (Voltage + Calcium) and use autoregistration
    # TODO build a better data tree for ROIs and Analysis
    INDEX_R, TYPE_R, POSITION, SIZE, FRAMES = range(5)
    INDEX_A, ROI, TYPE_A, ROI_CALC, FILTER, PEAKS = range(6)

    def __init__(self, parent=None, f_path=None, f_name=None, f_ext=None):
        # Initialization of the superclass
        super(DesignerSubWindowTiff, self).__init__(parent)
        # Setup the GUI
        self.setupUi(self)
        pg.setConfigOptions(background=pg.mkColor(0.1))
        pg.setConfigOptions(foreground=pg.mkColor(0.3))
        # Preserve plot area's aspect ration so image always scales correctly
        self.graphicsView.p1.setAspectLocked(True)
        # Connect the scrollbar's value signal to trigger a video update
        self.horizontalScrollBar.valueChanged['int'].connect(self.updateVideo)
        # Load the video file
        self.video_path = f_path
        self.video_name = f_name
        self.video_ext = f_ext
        self.video_file, self.dt = tifopen.tifopen(self.video_path, self.video_name + self.video_ext)
        # print('tifopen finished')
        # get video properties
        self.video_shape = self.video_file.shape
        if len(self.video_shape) < 3:
            raise Exception('TIFF has less than 3 dimensions')
        self.frames = self.video_shape[0]

        # Transpose second and third axes (y, x) to correct orientation (x, y)
        self.video_data = np.transpose(self.video_file, (0, 2, 1))
        # Flip each frame in the left/right direction, expected to be up/down
        for i in range(self.frames):
            self.video_data[i] = np.fliplr(self.video_data[i])

        # Use a dummy dt (aka Frame Period) if none detected
        # From most MetaMorph videos: exposure time 1.219 ms -> dt = 1.238 ms
        if np.isnan(self.dt):
            self.framePeriodMsLabel.setText('!Frame Period (ms)')
            self.dt = 1.238

        self.study = 'NaN'     # e.g. 20190418-ratb
        self.fps = 1000 / self.dt
        self.duration = self.fps * (self.frames + 1)
        self.width, self.height = self.video_shape[2], self.video_shape[1]
        self.resolution = None  # cm/px
        print('video shape:         ', self.video_shape)
        print('Width x Height:      ', self.width, self.height)
        print('# of Frames:         ', self.frames)
        print('Frame Period (ms):   ', self.dt)
        print('FPS:                 ', self.fps)
        print('Duration (ms):       ', self.duration)

        # Set-up Properties fields
        self.SizeLabelEdit.setText(str(self.width) + ' X ' + str(self.height) + ' (X ' + str(self.frames) + ')')

        self.subjectLineEdit.textEdited.connect(self.updateProperties)
        self.framePeriodMsLineEdit.setText(str(self.dt))
        self.framePeriodMsLineEdit.setEnabled(False)
        self.frameRateLineEdit.setText(str(self.fps))
        self.frameRateLineEdit.setEnabled(False)
        self.durationMsLineEdit.setText(str(self.duration))
        self.durationMsLineEdit.setEnabled(False)
        self.resolutionLineEdit.textEdited.connect(self.updateProperties)

        # Setup Signals UI for splitting options
        self.pushButtonSignalAdd.pressed.connect(self.splitVideo)
        self.pushButtonSignalRemove.pressed.connect(self.reduceVideo)

        # Setup ROIs and Anlysis variables
        self.ROIs = []  # A list of pg.ROI objects
        self.Analysis = []  # A list of Analysis results dictionaries
        self.analysis_default = {'ROI': '0', 'INDEX_A': np.nan, 'TYPE': 'Voltage',
                                 'ROI_CALC': 'Mean', 'FILTER': '60', 'PEAKS': '0.72,172',
                                 'RESULTS': None}
        # Set scroll bar maximum to number of frames
        self.horizontalScrollBar.setMinimum(1)
        self.horizontalScrollBar.setMaximum(self.frames)
        self.frame_current = 0
        # Set histogram to image levels and use a manual range
        self.graphicsView.hist.setLevels(self.video_data.min(), self.video_data.max())
        self.graphicsView.hist.setHistogramRange(self.video_data.min(), self.video_data.max())

        # Setup data treeviews
        # Calling it a treeview, currently connected to table-like models
        # ROI model
        self.treeViewROIs.setAlternatingRowColors(True)
        self.modelRoi = QStandardItemModel(0, 5)
        self.modelRoi.setHeaderData(self.INDEX_R, Qt.Horizontal, "#")
        self.modelRoi.setHeaderData(self.TYPE_R, Qt.Horizontal, "Type")
        self.modelRoi.setHeaderData(self.POSITION, Qt.Horizontal, "Position (X,Y)")
        self.modelRoi.setHeaderData(self.SIZE, Qt.Horizontal, "Size (px)")
        self.modelRoi.setHeaderData(self.FRAMES, Qt.Horizontal, "Frames")
        self.treeViewROIs.setModel(self.modelRoi)
        for idx in range(5):
            self.treeViewROIs.resizeColumnToContents(idx)
        # TODO use single-click to highlight ROI

        # Analysis model
        self.treeViewAnalysis.setAlternatingRowColors(True)
        self.modelAnalysis = QStandardItemModel(0, 6)
        self.modelAnalysis.setHeaderData(self.INDEX_A, Qt.Horizontal, "#")
        self.modelAnalysis.setHeaderData(self.ROI, Qt.Horizontal, "ROI#")
        self.modelAnalysis.setHeaderData(self.TYPE_A, Qt.Horizontal, "Type")
        self.modelAnalysis.setHeaderData(self.ROI_CALC, Qt.Horizontal, "ROI Calc.")
        self.modelAnalysis.setHeaderData(self.FILTER, Qt.Horizontal, "Filter")
        self.modelAnalysis.setHeaderData(self.PEAKS, Qt.Horizontal, "Peak Det.")
        self.treeViewAnalysis.setModel(self.modelAnalysis)
        for idx in range(6):
            self.treeViewAnalysis.resizeColumnToContents(idx)
        # TODO use single-click to highlight ROI
        # TODO use double-click to view analysis results
        print('WidgetTiff ready')

    def updateProperties(self):
        """Update TIFF parameters with user-entered values"""
        # TODO Invalidate old results when these change?
        print('** Updating properties')
        self.study = self.subjectLineEdit.text()
        self.resolution = self.resolutionLineEdit.text()

    def updateVideo(self, frame=0):
        """Updates the video frame drawn to the canvas"""
        # print('Updating video plot in a subWindow with:')
        print('*** Showing ' + self.video_name + '[' + str(frame) + ']')
        # Update ImageItem with a frame in stack
        self.frame_current = frame
        self.graphicsView.img.setImage(self.video_data[frame - 1])
        # Notify histogram item of image change
        self.graphicsView.hist.regionChanged()

        # Draw ROIs
        if self.ROIs:
            for roi in self.ROIs:
                self.graphicsView.p1.addItem(roi)

    def splitVideo(self):
        """Splits and aligns a multi-signal video"""
        print('*** Splitting video')

    def reduceVideo(self):
        """Reduce the number of signals/videos after splitting"""
        print('*** Reducing video')

    def getRoiPreview(self, roi):
        data = self.video_data[self.frame_current]
        data_img = self.graphicsView.img
        data_preview = roi.getArrayRegion(data, data_img)
        return data_preview

    def getRoiStack(self, roi):
        data_stack = []
        for idx, frame in enumerate(self.video_data):
            data_img = self.graphicsView.img
            data_roi_frame = roi.getArrayRegion(frame, data_img)
            data_roi_frame[data_roi_frame == 0] = np.nan
            data_stack.append(data_roi_frame)
        return data_stack

    def addROI(self, idx=None, roi=None, frames=None):
        print('*** addROI: idx:', idx, ' roi:', roi, ' frames:', frames)
        if roi:
            print('* ROIs were: ', self.ROIs)
            roi.translatable = False
            roi_state = roi.getState()
            x, y = str(int(roi_state['pos'].x())), str(int(roi_state['pos'].y()))
            position = x + ',' + y
            r = int(roi_state['size'][0])

            if idx is not None:
                roi_current = self.ROIs[idx]
                print('** Changing existing Analysis from: ', roi_current)
                print('**                              to: ', roi)
                roi_current.setState(roi_state)
                roi_current.setPen(color='54FF00')
            else:
                print('** Adding passed ROI: ', roi)
                length = self.modelRoi.rowCount()
                idx = length
                self.modelRoi.insertRow(idx)
                roi_new = pg.CircleROI([x, y], [r, r], pen=(2, 9), movable=False)
                roi_new.setPen(color='54FF00')
                self.graphicsView.p1.addItem(roi_new)
                self.ROIs.append(roi_new)
                roi_new.removeHandle(0)
            if not frames:
                frames = '1-' + str(self.frames)

            self.modelRoi.setData(self.modelRoi.index(idx, self.INDEX_R), idx)
            self.modelRoi.setData(self.modelRoi.index(idx, self.TYPE_R), 'Circle')
            self.modelRoi.setData(self.modelRoi.index(idx, self.POSITION), position)
            self.modelRoi.setData(self.modelRoi.index(idx, self.SIZE), r)
            self.modelRoi.setData(self.modelRoi.index(idx, self.FRAMES), frames)
            for idx in range(5):
                self.treeViewROIs.resizeColumnToContents(idx)
            # print('* ROIs are now: ', self.ROIs)
        else:
            print('** No ROI to add!')

    def removeROI(self, idx=None, roi=None):
        if roi:
            print('** Removing passed ROI: ', roi)
            rois_new = [j for i, j in enumerate(self.ROIs) if i not in [idx]]
            self.ROIs = rois_new
            self.modelRoi.removeRow(idx)
            self.graphicsView.p1.removeItem(roi)
            for idx in range(5):
                self.treeViewROIs.resizeColumnToContents(idx)
        else:
            print('** No ROI to remove!')

    def addAnalysis(self, idx=None, analysis=None):
        if analysis:
            print('*** addAnalysis: idx:', idx, ' analysis:', analysis)
            roi = analysis['ROI']
            analysis_type = analysis['TYPE']
            roi_calc = analysis['ROI_CALC']
            analysis_filter = analysis['FILTER']
            peaks = analysis['PEAKS']
            if idx is not None:
                analysis_current = self.Analysis[idx]
                print('** Changing existing Analysis from: ', analysis_current)
                print('**                              to: ', analysis)
                self.Analysis[idx] = analysis.copy()
            else:
                print('** Adding passed Analysis: ', analysis)
                self.Analysis.append(analysis.copy())
                length = self.modelAnalysis.rowCount()
                idx = length
                self.modelAnalysis.insertRow(idx)

            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.INDEX_A), str(idx))
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.ROI), roi)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.TYPE_A), analysis_type)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.ROI_CALC), roi_calc)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.FILTER), analysis_filter)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.PEAKS), peaks)
            for idx in range(6):
                self.treeViewAnalysis.resizeColumnToContents(idx)
        else:
            print('** No Analysis to add!')

    def removeAnalysis(self, idx=None, analysis=None):
        if analysis:
            print('* Removing passed Analysis: ', analysis)
            analysis_new = [j for i, j in enumerate(self.Analysis) if i not in [idx]]
            self.Analysis = analysis_new
            self.modelAnalysis.removeRow(idx)
            for idx in range(6):
                self.treeViewAnalysis.resizeColumnToContents(idx)
        else:
            print('* No Analysis to remove!')


class DesignerSubWindowFolder(QWidget, Ui_WidgetFolderTree):
    """Customization for Ui_WidgetFolderTree subwindow for an MDI"""

    def __init__(self, parent=None, root=None):
        # initialization of the superclass
        super(DesignerSubWindowFolder, self).__init__(parent)
        self.dir = QDir(root)
        self.currentFileName = ''
        self.currentFilePath = ''
        # setup the GUI
        self.setupUi(self)
        print('WidgetFolderTree UI setup')
        self.model = QFileSystemModel()
        self.model.setRootPath(root)
        self.treeView.setModel(self.model)
        self.treeView.setRootIndex(self.model.index(root))
        print('treeView ready')

    @QtCore.pyqtSlot(QtCore.QModelIndex)
    def on_treeView_clicked(self, index):
        index_item = self.model.index(index.row(), 0, index.parent())
        self.currentFileName = self.model.fileName(index_item)
        self.currentFilePath = self.model.filePath(index_item)
        print('Clicked: ' + self.currentFilePath + ' ' + self.currentFileName)


class DesignerSubWindowIsolate(QWidget, Ui_WidgetIsolate):
    """Customization for Ui_WidgetIsolate subwindow for an MDI"""
    # TODO Fix preview redundancies (updating image and plot multiple times per ROI change)
    # TODO Detect isolation of split/autoregistered video
    # TODO move *NEW* combobox items to the ends, rather than the beginnings

    def __init__(self, parent=None, w_list=None):
        # initialization of the superclass
        super(DesignerSubWindowIsolate, self).__init__(parent)
        print('Creating WidgetIsolate')
        self.windowList = w_list
        self.currentFileName = ''
        self.currentFilePath = ''
        self.windowDict = {}  # Dictionary with structure "window_name_short": "window"
        name_limit = 50
        for w in self.windowList:
            w_name = w.widget().objectName()
            w_name_short = '..' + w_name[-name_limit:] if len(w_name) > name_limit else w_name
            # Populate dictionary
            self.windowDict[w_name_short] = w.widget()
        self.currentWindow = None
        self.currentPlot = None
        self.currentROIs = []
        self.roi_preview = None
        self.condition_results = None
        # setup the GUI
        print('WidgetIsolate UI setup...')
        self.setupUi(self)
        # Setup preview plot in isolate subwindow
        # TODO remove border around preview, maybe switch to:
        #         self.rawImg = RawImageWidget(QWidget())
        w_preview = self.widgetPreview.addLayout(row=0, col=0)
        self.v_preview = w_preview.addViewBox(lockAspect=True)
        self.img_preview = pg.ImageItem()
        self.v_preview.addItem(self.img_preview)
        self.v_preview.disableAutoRange('xy')
        self.v_preview.autoRange()
        self.plot_preview = self.widgetPreviewPlot.addPlot()

        self.comboBoxSource.addItems(self.windowDict.keys())
        self.comboBoxSource.currentIndexChanged['int'].connect(self.selectionMadeSource)
        self.comboBoxROIs.currentIndexChanged['int'].connect(self.selectionMadeROI)

        self.checkBoxTimeAll.stateChanged.connect(self.checkBoxChangedTimeAll)

        self.buttonBox.button(QDialogButtonBox.RestoreDefaults).clicked.connect(self.loadDefaults)
        self.buttonBox.button(QDialogButtonBox.Apply).clicked.connect(self.applyROI)
        self.buttonBox.button(QDialogButtonBox.Discard).clicked.connect(self.discardROI)
        self.checkBoxPreview.stateChanged.connect(self.checkBoxChangedPreview)
        self.buttonBox.button(QDialogButtonBox.Apply).setEnabled(False)
        self.selectionMadeSource(0)

        self.startSpinBox.setMaximum(self.currentWindow.frames)
        self.endSpinBox.setMaximum(self.currentWindow.frames)
        self.endSpinBox.setValue(self.currentWindow.frames)
        self.checkBoxTimeAll.setChecked(True)
        print('WidgetIsolate ready')

    def closeEvent(self, event):
        """Reimplementation of QWidget.closeEvent

        Parameters
        ----------
        event : PySide2.QtGui.QCloseEvent
            Event when Qt receives a window close request for a top-level widget from the window system
        """
        for roi in self.currentWindow.ROIs:
            roi.setPen(color='54FF00')
        self.checkBoxPreview.setChecked(False)
        event.accept()

    def selectionMadeSource(self, i):
        """Slot for comboBoxSource.currentIndexChanged"""
        print('** selection made in a ', type(self))
        print('* Current source: ', i, ', ', self.comboBoxSource.currentText())
        self.currentWindow = self.windowDict[self.comboBoxSource.currentText()]
        self.currentPlot = self.currentWindow.graphicsView.p1

        self.currentROIs = self.currentWindow.ROIs
        self.comboBoxROIs.clear()
        self.comboBoxROIs.addItem('*New*')
        for idx, roi in enumerate(self.currentROIs):
            self.comboBoxROIs.addItem(str(idx) + ': ' + str(roi.saveState()))
            print('Listing ROI #', idx, ': ', roi)

        print('* Window: ', str(self.currentWindow))
        print('* W x H: ', str(self.currentWindow.width), ' X ', str(self.currentWindow.height))
        print('* ROIs: ', str(self.currentROIs))
        self.loadDefaults()

    def selectionMadeROI(self, i):
        """Slot for comboBoxROIs.currentIndexChanged"""
        print('** selection made in a ', type(self))
        print('* Current ROI: #', i, ': ', self.comboBoxROIs.currentText())
        for roi in self.currentWindow.ROIs:
            roi.setPen(color='54FF00')
        index_current = self.comboBoxROIs.currentIndex()
        if index_current > 0:
            # An existing ROI has been selected
            # self.checkBoxPreview.setChecked(False)
            roi_current = self.currentWindow.ROIs[index_current - 1]
            print('* ROI #', index_current - 1, ': ', str(roi_current))
            roi_current.setPen(color='FF000A')
            # self.roi_preview = roi_current
            self.updateParameters(roi_current)
        else:
            # *NEW* has been selected
            self.loadDefaults()

    def loadDefaults(self):
        """Populate ROI parameter inputs with default values"""
        print('* Loading defaults')
        default_r = 15
        # Populate fields with default values
        self.originXLineEdit.setText(str(int(self.currentWindow.width / 2)))
        self.originYLineEdit.setText(str(int(self.currentWindow.height / 2)))
        self.radiusSpinBox.setValue(default_r)

    def updateParameters(self, roi):
        """Populate ROI parameter inputs with an existing ROI's parameters"""
        roi_state = roi.getState()
        x, y = str(int(roi_state['pos'].x())), str(int(roi_state['pos'].y()))
        r = int(roi_state['size'][0])
        # print("Updating roi params with: ", x, ' ', y, ' ', r)
        # Populate fields with passed values
        self.originXLineEdit.setText(x)
        self.originYLineEdit.setText(y)
        self.radiusSpinBox.setValue(r)

    def checkBoxChangedTimeAll(self):
        """Toggle use of all frames of a video for the current ROI"""
        print('** checkBoxChangedTimeAll')
        if self.checkBoxTimeAll.isChecked():
            self.startSpinBox.setValue(1)
            self.startSpinBox.setEnabled(False)
            self.endSpinBox.setValue(self.currentWindow.frames)
            self.endSpinBox.setEnabled(False)
            print('* UseAll checked')
        else:
            self.startSpinBox.setEnabled(True)
            self.endSpinBox.setEnabled(True)
            print('* UseAll unchecked')

    def checkBoxChangedPreview(self):
        """Create/destroy preview ROI and read parameter entries"""
        print('** checkBoxChangedPreview')
        if self.checkBoxPreview.isChecked():
            if not self.roi_preview:
                # Get current ROI values
                x, y = int(self.originXLineEdit.text()), int(self.originYLineEdit.text())
                r = self.radiusSpinBox.value()
                # Create preview ROI if it doesn't exist
                self.roi_preview = pg.CircleROI([x, y], [r, r], pen=(2, 9), scaleSnap=True, translateSnap=True)
                self.roi_preview.setPen(color='FF8700')
                # Draw region on current tiff window's plot
                self.currentPlot.addItem(self.roi_preview)
                self.roi_preview.sigRegionChanged.connect(self.updatePreviewImage)
                self.roi_preview.sigRegionChanged.connect(lambda: self.updateParameters(self.roi_preview))
                # self.roi_preview.sigRegionChangeFinished.connect(self.updatePreviewPlot)

                self.originXLineEdit.textEdited.connect(self.updatePreviewROI)
                self.originYLineEdit.textEdited.connect(self.updatePreviewROI)
                self.radiusSpinBox.valueChanged.connect(self.updatePreviewROI)
                self.updatePreviewROI()
                # self.updatePreviewPlot()
                print('** Created preview ROI')
        else:
            # Remove preview ROI
            self.currentPlot.removeItem(self.roi_preview)
            self.roi_preview = None
            self.buttonBox.button(QDialogButtonBox.Apply).setEnabled(False)
            print('** Removed preview ROI')

    def updatePreviewROI(self):
        """Update ROI preview in Isolate subwindow"""
        print('** updatePreviewROI')
        if self.roi_preview:
            # ROI Preview exists, update the params
            # Get current ROI values
            x, y = int(self.originXLineEdit.text()), int(self.originYLineEdit.text())
            r = self.radiusSpinBox.value()
            self.roi_preview.setPos((x, y))
            self.roi_preview.setSize(r)

            self.updatePreviewImage()
            print('** Set ROI preview')
        else:
            print('** No ROI preview to update, clearing!')

    def updatePreviewImage(self):
        """Update ROI preview image in Isolate subwindow"""
        print('** updatePreviewImage')
        if self.roi_preview:
            # Get current video frame data and preview ROI data
            data_frame = self.currentWindow.video_data[self.currentWindow.frame_current]
            data_preview = self.currentWindow.getRoiPreview(self.roi_preview)

            # self.roi_preview.setParentItem(img_preview)
            # Draw preview data in isolate subwindow
            self.img_preview.setImage(data_preview, levels=(0, data_frame.max()))
            self.v_preview.autoRange()
            self.buttonBox.button(QDialogButtonBox.Apply).setEnabled(True)
            print('** Set ROI preview image')
        else:
            self.v_preview.clear()
            print('** No ROI preview image to update, clearing!')

    def updatePreviewPlot(self):
        """Update ROI preview plot in Isolate subwindow"""
        print('** updatePreviewPlot')
        if self.roi_preview:
            # Calculate conditioned ROI data across all frames
            print('* Calculating ROI mean')
            roi_data = self.currentWindow.getRoiStack(self.roi_preview)
            roi_data_mean = np.zeros(self.currentWindow.frames)
            for idx, frame in enumerate(roi_data):
                roi_data_mean[idx] = np.nanmean(frame)
            roi_data_mean_norm = np.copy(roi_data_mean)
            norm_MIN = roi_data_mean_norm.min()
            norm_MAX = roi_data_mean_norm.max()
            roi_data_mean_norm = (roi_data_mean_norm - norm_MIN) / (norm_MAX - norm_MIN)
            # if 'Voltage' in self.analysis_preview['TYPE']:
            # roi_data_mean_norm = 1 - roi_data_mean_norm
            print('* ROI mean calculated')
            self.condition_results = roi_data_mean_norm
            # Plot conditioned signal
            self.plot_preview.plot(self.condition_results, clear=True)
            print('** Set ROI preview plot')
        else:
            self.plot_preview.clear()
            print('** No ROI preview plot to update, clearing!')

    def applyROI(self):
        """Add an ROI to a TIFF or applies changes to an existing ROI"""
        if not self.roi_preview:
            print('*** No roi_preview to add or edit with')
            return
        else:
            if not self.checkBoxTimeAll.isChecked():
                frames = self.startSpinBox.text() + '-' + self.endSpinBox.text()
            else:
                frames = None
            if self.comboBoxROIs.currentIndex() is 0:
                # Add the preview ROI to the current TIFF window
                print('*** Applying *NEW* ROI ')
                self.currentWindow.addROI(roi=self.roi_preview, frames=frames)
            else:
                # Set state of the chosen ROI (current list index - 1, due to *NEW* at index 0)
                idx_roi = self.comboBoxROIs.currentIndex() - 1
                print('*** Changing ROI #' + str(idx_roi))
                roi_current = self.currentROIs[idx_roi]
                self.currentWindow.addROI(idx=idx_roi, roi=self.roi_preview, frames=frames)
                roi_current.setPen(color='54FF00')
            self.checkBoxPreview.setChecked(False)
            self.selectionMadeSource(0)

    def discardROI(self):
        """Remove an existing ROI from a TIFF"""
        print('*** Discarding ROI')
        if self.comboBoxROIs.currentIndex() is 0:
            print('*** Cannot discard *NEW* ROI!')
        else:
            if len(self.currentROIs) < 1:
                print('*** No ROIs to discard!')
            else:
                print('** Removing ROI: ', self.comboBoxROIs.currentText())
                idx_roi = self.comboBoxROIs.currentIndex() - 1
                roi_current = self.currentROIs[idx_roi]

                self.currentWindow.removeROI(idx=idx_roi, roi=roi_current)

                self.checkBoxPreview.setChecked(False)
                self.selectionMadeSource(0)


class DesignerSubWindowAnalyze(QWidget, Ui_WidgetAnalyze):
    """Customization for Ui_WidgetAnalyze subwindow for an MDI"""
    # TODO clean up Apply and OK UI flow

    def __init__(self, parent=None, w_list=None):
        # initialization of the superclass
        super(DesignerSubWindowAnalyze, self).__init__(parent)
        print('Creating WidgetAnalyze')
        self.windowList = w_list
        self.currentFileName = ''
        self.currentFilePath = ''
        self.windowDict = {}  # Dictionary with structure "window_name_short": "window"
        name_limit = 50
        for w in self.windowList:
            w_name = w.widget().objectName()
            w_name_short = '..' + w_name[-name_limit:] if len(w_name) > name_limit else w_name
            # Populate dictionary
            self.windowDict[w_name_short] = w.widget()
        self.currentWindow = None
        self.currentVideoPlot = None
        self.currentROIs = []
        self.currentAnalysis = []
        self.roi_current = None
        self.analysis_preview = None
        self.condition_results = None
        self.peak_results = None
        self.process_results = None

        # setup the GUI
        print('WidgetAnalyze UI setup...')
        self.setupUi(self)
        self.plot_preview = self.widgetPreview.addPlot()
        self.filterCheckBox.stateChanged.connect(self.filterCheckBoxChanged)
        self.tabPeakDetect.setEnabled(False)
        self.tabProcess.setEnabled(False)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)

        self.comboBoxSource.addItems(self.windowDict.keys())
        self.comboBoxSource.currentIndexChanged['int'].connect(self.selectionMadeSource)
        self.comboBoxROIs.currentIndexChanged['int'].connect(self.selectionMadeROI)
        self.comboBoxAnalysis.currentIndexChanged['int'].connect(self.selectionMadeAnalysis)

        self.buttonBoxCondition.button(QDialogButtonBox.Apply).clicked.connect(self.applyCondition)
        self.buttonBoxPeakDetect.button(QDialogButtonBox.Apply).clicked.connect(self.applyPeakDetect)
        self.buttonBoxProcess.button(QDialogButtonBox.Apply).clicked.connect(self.applyProcess)

        self.buttonBoxAnalyze.button(QDialogButtonBox.RestoreDefaults).clicked.connect(self.loadDefaults)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).clicked.connect(self.applyAnalysis)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Discard).clicked.connect(self.discardAnalysis)
        # self.checkBoxPreview.stateChanged.connect(self.checkBoxChangedPreview)
        self.progressBar.setValue(0)
        self.selectionMadeSource(0)
        # self.listWidgetOpenTiffs.addItems(self.windowListNames)
        print('WidgetAnalyze ready')

    def closeEvent(self, event):
        """Reimplementation of QWidget.closeEvent

        Parameters
        ----------
        event : PySide2.QtGui.QCloseEvent
            Event when Qt receives a window close request for a top-level widget from the window system
        """
        for roi in self.currentWindow.ROIs:
            roi.setPen(color='54FF00')
        event.accept()

    def selectionMadeSource(self, i):
        """Slot for comboBoxSource.currentIndexChanged"""
        print('*** selection #', i, ' made in a ', type(self))
        print('* Current source: ', self.comboBoxSource.currentText())
        self.currentWindow = self.windowDict[self.comboBoxSource.currentText()]
        self.currentVideoPlot = self.currentWindow.graphicsView.p1

        self.comboBoxROIs.clear()
        self.currentROIs = self.currentWindow.ROIs
        for idx, roi in enumerate(self.currentROIs):
            self.comboBoxROIs.addItem(str(idx) + ': ' + str(roi.saveState()))
            print('Listing ROI #', idx, ': ', roi)

        self.comboBoxAnalysis.clear()
        self.currentAnalysis = self.currentWindow.Analysis
        self.comboBoxAnalysis.addItem('*New*')
        for idx, analysis in enumerate(self.currentAnalysis):
            analysis_display = '#' + str(idx) + ': ' + analysis['TYPE']
            self.comboBoxAnalysis.addItem(str(idx) + ': ' + analysis_display)
            print('Listing Analysis #', idx, ': ', analysis_display)

        print('* Window: ', str(self.currentWindow))
        print('* W x H: ', str(self.currentWindow.width), ' X ', str(self.currentWindow.height))
        print('* ROIs: ', str(self.currentROIs))
        print('* Analysis: ', str(self.currentAnalysis))
        # self.loadDefaults()

    def selectionMadeROI(self, i):
        """Slot for comboBoxROIs.currentIndexChanged"""
        print('*** selection #', i, ' made in a ', type(self))
        print('** Current ROI: ', self.comboBoxROIs.currentText())
        for roi in self.currentWindow.ROIs:
            roi.setPen(color='54FF00')
        index_current = self.comboBoxROIs.currentIndex()
        # An existing ROI has been selected
        self.roi_current = self.currentWindow.ROIs[index_current]
        print('* ROI: ', str(self.roi_current))
        self.roi_current.setPen(color='FF000A')
        self.progressBar.setValue(20)

    def selectionMadeAnalysis(self, i):
        """Slot for comboBoxAnalysis.currentIndexChanged"""
        print('*** selection #', i, ' made in a ', type(self))
        print('** Current Analysis: ', self.comboBoxAnalysis.currentText())
        index_current = self.comboBoxAnalysis.currentIndex()
        if index_current > 0:
            # An existing Analysis has been selected
            self.analysis_preview = self.currentWindow.Analysis[index_current - 1]
            print('* Analysis #', index_current - 1, ': ', str(self.analysis_preview))
            self.updateParameters(self.analysis_preview)
        else:
            # *NEW* has been selected
            self.loadDefaults()

    def loadDefaults(self):
        """Populate Analysis parameter inputs with default values"""
        print('** loadDefaults!')
        self.analysis_preview = self.currentWindow.analysis_default.copy()
        self.updateParameters(self.currentWindow.analysis_default)
        if self.tabProcess.isEnabled():
            self.tabProcess.setEnabled(False)
            self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
        if self.tabPeakDetect.isEnabled():
            self.tabPeakDetect.setEnabled(False)
        self.plot_preview.clear()
        self.progressBar.setValue(20)
        self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabCondition)

    def updateParameters(self, analysis):
        """Populate Analysis parameter inputs with an existing Analysis's parameters"""
        print('** Updating Analysis parameters')
        roi = analysis['ROI']
        analysis_type = analysis['TYPE']
        roi_calc = analysis['ROI_CALC']
        analysis_filter = analysis['FILTER']
        peaks_thresh, peaks_lockout = analysis['PEAKS'].split(',')
        print("* using Analysis parameters: ", roi, ' ', analysis_type, ' ', roi_calc, ' ', analysis_filter, ' ',
              peaks_thresh, ',', peaks_lockout, ' ', process)

        # Populate fields with passed values
        self.signalTypeComboBox.setCurrentText(str(analysis_type))
        self.roiCalculationComboBox.setCurrentText(roi_calc)
        if pd.isna(analysis_filter):
            self.filterCheckBox.setChecked(False)
        else:
            self.filterCheckBox.setChecked(True)
            self.filterFreqSpinBox.setValue(int(analysis_filter))
        self.thresholdDoubleSpinBox.setValue(float(peaks_thresh))
        self.lockoutTimeSpinBox.setValue(int(peaks_lockout))
        # self.allResultsCheckBoxVm.setChecked(process == 'ALL')
        # self.allResultsCheckBoxCa.setChecked(process == 'ALL')

    def filterCheckBoxChanged(self):
        """Toggle use of a low pass filter for the current conditioning"""
        if self.filterCheckBox.isChecked():
            self.filterFreqSpinBox.setEnabled(True)
            print('*** Filter checked')
        else:
            self.filterFreqSpinBox.setEnabled(False)
            print('*** Filter unchecked')

    def applyCondition(self):
        """Apply Condition tab selections"""
        # TODO use ROI's frame info
        print('*** Applying Condition, Signal Type:', self.signalTypeComboBox.currentText(),
              ' ROI Calc.:', self.roiCalculationComboBox.currentText())
        self.progressBar.setValue(20)
        self.analysis_preview['ROI'] = str(self.comboBoxROIs.currentIndex())
        self.analysis_preview['TYPE'] = self.signalTypeComboBox.currentText()
        self.analysis_preview['ROI_CALC'] = self.roiCalculationComboBox.currentText()
        if self.filterCheckBox.isChecked():
            self.analysis_preview['FILTER'] = str(self.filterFreqSpinBox.value())
        else:
            self.analysis_preview['FILTER'] = np.nan
        print('** analysis_preview: ', self.analysis_preview)

        # Calculate conditioned ROI data across all frames
        print('** ROI_CALC is ', self.analysis_preview['ROI_CALC'])
        if 'Mean' in self.analysis_preview['ROI_CALC']:
            print('* Calculating ROI mean')
            roi_data = self.currentWindow.getRoiStack(self.roi_current)
            roi_data_mean = np.zeros(self.currentWindow.frames)
            for idx, frame in enumerate(roi_data):
                roi_data_mean[idx] = np.nanmean(frame)
            roi_data_mean_norm = np.copy(roi_data_mean)
            norm_MIN = roi_data_mean_norm.min()
            norm_MAX = roi_data_mean_norm.max()
            roi_data_mean_norm = (roi_data_mean_norm - norm_MIN) / (norm_MAX - norm_MIN)
            if 'Voltage' in self.analysis_preview['TYPE']:
                # TODO Signal type should determine Process tab's results options
                roi_data_mean_norm = 1 - roi_data_mean_norm
            print('* ROI mean calculated')
            if self.filterCheckBox.isChecked():
                print('* Filtering ROI mean ')
                fs = 1 / (self.currentWindow.dt / 1000)
                Wn = (self.filterFreqSpinBox.value() / (fs / 2))
                [b, a] = sig.butter(5, Wn)
                roi_data_mean_norm_filt = sig.filtfilt(b, a, roi_data_mean_norm)
                print('* ROI mean filtered')
                self.condition_results = roi_data_mean_norm_filt
            else:
                self.condition_results = roi_data_mean_norm
        else:
            print('* UNKNOWN ROI_CALC! : ', self.analysis_preview['ROI_CALC'])
        # Plot conditioned signal
        self.plot_preview.plot(self.condition_results, clear=True)

        if self.tabProcess.isEnabled():
            self.tabProcess.setEnabled(False)
            self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
        self.tabPeakDetect.setEnabled(True)
        self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabPeakDetect)
        self.progressBar.setValue(60)
        print('*** Finished Applying Condition')

    def applyPeakDetect(self):
        """Apply Peak Detect tab selections"""
        # Detection Error @ trans#  0  our of  7
        # t0_locs[trans]  70 , up_locs[trans]  72 , peak_locs[trans]  75 , base_locs[trans]  14
        # TODO set y axis to frames, not kframes
        print('*** Applying Peak Detect, Threshold:', self.thresholdDoubleSpinBox.value(),
              ' Lockout Time:', self.lockoutTimeSpinBox.value())
        self.progressBar.setValue(60)
        thresh = self.thresholdDoubleSpinBox.value()
        lockout = self.lockoutTimeSpinBox.value()
        param_peaks = str(thresh) + ',' + str(lockout)
        self.analysis_preview['PEAKS'] = param_peaks
        print('** analysis_preview: ', self.analysis_preview)

        print('** PEAKS is ', self.analysis_preview['PEAKS'])
        self.peak_results = peak_detect.peak_detect(f=self.condition_results, thresh=thresh, LOT=lockout)
        [num_peaks, t0_locs, up_locs, peak_locs, base_locs, max_vel, peak_thresh] = self.peak_results
        print('** Detected ', num_peaks, ' peaks above ', peak_thresh)
        print('* max_vel: ', max_vel)

        # Redraw conditioned signal
        self.plot_preview.plot(self.condition_results, clear=True)
        # Mark t0_locs, yellow
        self.plot_preview.plot(t0_locs, self.condition_results[t0_locs], pen=None,
                               symbol='t1', symbolPen=None, symbolSize=10, symbolBrush=(250, 194, 5, 200))
        # Mark up_locs, orange
        self.plot_preview.plot(up_locs, self.condition_results[up_locs], pen=None,
                               symbol='t1', symbolPen=None, symbolSize=10, symbolBrush=(217, 83, 25, 200))
        # Mark peaks, red
        self.plot_preview.plot(peak_locs, self.condition_results[peak_locs], pen=None,
                               symbol='t1', symbolPen=None, symbolSize=10, symbolBrush=(255, 5, 5, 200))
        # Mark base_locs, grey
        self.plot_preview.plot(base_locs, self.condition_results[base_locs], pen=None,
                               symbol='t1', symbolPen=None, symbolSize=10, symbolBrush=(100, 100, 100, 200))
        print('* Peak results (signal, t0_locs, up_locs, peaks, base_locs) plotted')
        # # Mark upstroke
        # for slope in up_locs:
        #     vLine = pg.InfiniteLine(pos=slope, angle=90, movable=False, pen=[100, 255, 100, 80])
        #     self.plot_preview.addItem(vLine)
        #     # Mark the return to baseline
        #     for baseline in base_locs:
        #         if baseline > slope:
        #             vLine = pg.InfiniteLine(pos=baseline, angle=90, movable=False, pen=[100, 255, 100, 80])
        #             self.plot_preview.addItem(vLine)
        #             break
        self.plot_preview.setLabel('left', "Norm. Fluorescence")
        # self.plot_preview.setLabel('bottom', "Time", units='frames')
        # self.plot_preview.getAxis('bottom').enableAutoSIPrefix(enable=False)

        self.tabProcess.setEnabled(True)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
        self.progressBar.setValue(80)
        self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabProcess)
        print('*** Finished Applying Peak Detect')

    def applyProcess(self):
        """Apply Process tab selections"""
        print('*** Applying Process, All Results')
        self.progressBar.setValue(80)
        [num_peaks, t0_locs, up_locs, peak_locs, base_locs, max_vel, peak_thresh] = self.peak_results
        print('** Processing ', num_peaks, ' peaks above ', peak_thresh)
        print('** analysis_preview: ', self.analysis_preview)
        print('** PROCESS is gone, I am the captain now')

        per_base = 80
        F0 = np.nanmean((self.condition_results[base_locs[1]:t0_locs[0]]))
        # for idx in num_peaks:
        #     F0[idx] = np.nanmean((self.condition_results[base_locs[idx-1]:t0_locs[idx-1]]))
        if 'Voltage' in self.analysis_preview['TYPE']:
            probe = 1
        else:
            probe = 0
        try:
            self.process_results = process.process(self.condition_results, self.currentWindow.dt,
                                                   t0_locs, up_locs, peak_locs, base_locs, max_vel, per_base, F0, probe)
        except Exception:
            traceback.print_exc()
            # ex_type, ex_value, ex_traceback = sys.exc_info()
            # self.parentWidget().parentWidget().statusBar().showMessage('Failed to open, ' + str(ex_type))

        self.analysis_preview['RESULTS'] = self.process_results
        print('* Process results calculated')

        table_model = PandasModel(self.process_results)
        self.processTableView.setModel(table_model)
        print('* Results table populated')

        self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(True)
        self.progressBar.setValue(100)
        print('*** Finished Applying Process')

    def applyAnalysis(self):
        """Add an Analysis to a TIFF or applies changes to an existing Analysis"""
        print('*** Applying Analysis')
        if not self.analysis_preview:
            print('** No analysis_preview to add or edit with')
        else:
            if self.comboBoxAnalysis.currentIndex() is 0:
                print('** Applying *NEW* Analysis')
                # self.currentWindow.addAnalysis(self.currentWindow.analysis_default)
                self.currentWindow.addAnalysis(analysis=self.analysis_preview)
            else:
                # Set state of the chosen Analysis (current list index - 1, due to *NEW* at index 0)
                idx_analysis = self.comboBoxAnalysis.currentIndex() - 1
                print('** Changing Analysis #' + str(idx_analysis))
                self.currentWindow.addAnalysis(idx=idx_analysis, analysis=self.analysis_preview)

            if self.tabProcess.isEnabled():
                self.tabProcess.setEnabled(False)
                self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
            if self.tabPeakDetect.isEnabled():
                self.tabPeakDetect.setEnabled(False)
            self.progressBar.setValue(20)
            self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabCondition)
            self.selectionMadeSource(0)
        print('*** Apply Analysis done')

    def discardAnalysis(self):
        """Remove an existing Analysis from a TIFF"""
        print('*** Discarding Analysis')
        if self.comboBoxAnalysis.currentIndex() is 0:
            print('** Cannot discard *NEW* Analysis!')
        else:
            if len(self.currentAnalysis) < 1:
                print('** No Analysis to discard!')
            else:
                print('** Removing Analysis: ', self.comboBoxAnalysis.currentText())
                idx_analysis = self.comboBoxAnalysis.currentIndex() - 1
                analysis_current = self.currentAnalysis[idx_analysis]

                self.currentWindow.removeAnalysis(idx=idx_analysis, analysis=analysis_current)

                if self.tabProcess.isEnabled():
                    self.tabProcess.setEnabled(False)
                    self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
                if self.tabPeakDetect.isEnabled():
                    self.tabPeakDetect.setEnabled(False)
                self.progressBar.setValue(20)
                self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabCondition)
                self.selectionMadeSource(0)
        print('*** Discard Analysis done')


class DesignerSubWindowExport(QWidget, Ui_WidgetExport):
    """Customization for Ui_WidgetExportCopyPaste subwindow for an MDI"""

    def __init__(self, parent=None, w_list=None):
        # initialization of the superclass
        super(DesignerSubWindowExport, self).__init__(parent)
        print('Creating WidgetCopyPaste')
        self.windowList = w_list
        self.currentFileName = ''
        self.currentFilePath = ''
        self.windowDict = {}  # Dictionary with structure "window_name_short": "window"
        name_limit = 50
        for w in self.windowList:
            w_name = w.widget().objectName()
            w_name_short = '..' + w_name[-name_limit:] if len(w_name) > name_limit else w_name
            # Populate dictionary
            self.windowDict[w_name_short] = w.widget()
        self.currentWindow = None
        self.currentAnalysis = None
        self.currentROI = None
        self.currentResults = None
        self.finalResults = None
        self.clip = QApplication.clipboard()
        # setup the GUI
        print('WidgetCopyPaste UI setup...')
        self.setupUi(self)
        self.comboBoxSource.addItems(self.windowDict.keys())
        self.comboBoxSource.currentIndexChanged['int'].connect(self.selectionMadeSource)
        self.comboBoxAnalysis.currentIndexChanged['int'].connect(self.selectionMadeAnalysis)

        self.radioButtonIndividual.toggled.connect(self.loadResults)
        self.radioButtonIndividual.setChecked(True)
        self.radioButtonMean.toggled.connect(self.loadResults)
        self.checkBoxSD.toggled.connect(self.loadResults)

        self.checkBoxProperties.setChecked(True)
        self.checkBoxProperties.stateChanged.connect(self.loadResults)
        self.checkBoxAPDs.setChecked(True)
        self.checkBoxAPDs.stateChanged.connect(self.loadResults)
        self.checkBoxOther.setChecked(False)
        self.checkBoxOther.stateChanged.connect(self.loadResults)
        self.checkBoxParameters.setChecked(False)
        self.checkBoxParameters.stateChanged.connect(self.loadResults)

        self.pushButtonCopy.clicked.connect(self.copyResults)
        self.pushButtonExport.clicked.connect(self.exportResults)
        self.selectionMadeSource(0)
        print('WidgetCopyPaste ready')

    def selectionMadeSource(self, i):
        """Slot for comboBoxSource.currentIndexChanged"""
        print('** selection made in a ', type(self))
        print('* Current source: ', i, ', ', self.comboBoxSource.currentText())
        self.currentWindow = self.windowDict[self.comboBoxSource.currentText()]

        self.comboBoxAnalysis.clear()
        for idx, analysis in enumerate(self.currentWindow.Analysis):
            roi, results_type = analysis['ROI'], analysis['TYPE']
            analysis_display = '#' + str(idx) + ': ' + results_type
            self.comboBoxAnalysis.addItem(analysis_display)
            print('Listing Analysis #', idx, ': ', analysis_display)

        print('*Window: ', str(self.currentWindow))
        print('*W x H: ', str(self.currentWindow.width), ' X ',
              str(self.currentWindow.height))

    def selectionMadeAnalysis(self, i):
        """Slot for comboBoxAnalysis.currentIndexChanged"""
        print('*** selection #', i, ' made in a ', type(self))
        print('** Current Analysis: ', self.comboBoxAnalysis.currentText())
        index_current = self.comboBoxAnalysis.currentIndex()
        self.currentAnalysis = self.currentWindow.Analysis[index_current]
        self.currentROI = self.currentAnalysis['ROI']
        self.currentResults = self.currentAnalysis['RESULTS']
        self.radioButtonIndividual.setChecked(True)
        self.finalResults = self.currentResults
        self.loadResults()

    def updateParameters(self):
        """Update Results parameters"""
        print('** Updating Results parameters')
        # try:
        #     if self.checkBoxAPDs.isChecked():
        #
        #     elif self.checkBoxPeriods.isChecked():
        #     else:
        #         if self.radioButtonAllResults.isChecked():
        #             self.checkBoxAPDs.setChecked(False)
        #             self.checkBoxPeriods.setChecked(False)
        #     self.loadResults()
        # except Exception:
        #     traceback.print_exc()

    def loadResults(self):
        """Populate Results table with the current Analysis' results"""
        # TODO create row/rows with subject, file_name, roi, analysis parameters
        # TODO redo to simplify: create full tables and filter at the end
        print('*** loadResults!')
        print('** currentResults:' + str(self.currentResults))
        if self.currentResults is None:
            print('*** No results yet!')
        else:
            print('** Found results')
            try:
                tempResults = pd.DataFrame()
                tempResultsProps = pd.DataFrame()
                tempResultsAPD = pd.DataFrame()
                tempResultsOther = pd.DataFrame()
                tempResultsParams = pd.DataFrame()

                # Filter based on desired values
                if self.checkBoxAPDs.isChecked():
                    print('* Using APDs')
                    tempResultsAPD = self.currentResults.iloc[:, 4:8]
                if self.checkBoxOther.isChecked():
                    print('* Using all other data')
                    tempResultsOther = self.currentResults.iloc[:, 9:]

                if not self.checkBoxOther.isChecked() and not self.checkBoxAPDs.isChecked():
                    print('* No results columns chosen!')
                tempResults = pd.concat([tempResultsAPD, tempResultsOther], axis=1)

                # Calculate means and SDs, if needed
                if self.radioButtonMean.isChecked():
                    print('* Using Mean results')
                    mean = tempResults.mean(axis=0)
                    mean_SD = pd.Series()
                    mean_combo = pd.Series()
                    self.checkBoxSD.setEnabled(True)
                    if self.checkBoxSD.isChecked():
                        print('* Using SD results')
                        mean_SD = tempResults.std(axis=0)
                        mean_SD_index = [s + '_SD' for s in mean_SD.index]
                        # mean_SD.index = mean_SD_index
                        # Interleave lists of means and SDs
                        mean_combo_list = [np.nan] * (2 * len(mean))
                        mean_combo_index = [np.nan] * (2 * len(mean))
                        mean_combo_list[::2] = mean
                        mean_combo_index[::2] = mean_SD.index
                        mean_combo_list[1::2] = mean_SD
                        mean_combo_index[1::2] = mean_SD_index
                        mean_combo = pd.Series(mean_combo_list)
                        mean_combo.index = mean_combo_index
                        # mean_combo = pd.Series([val for pair in zip(mean, mean_SD) for val in pair])
                    else:
                        mean_combo = mean
                    # tempResults.loc[0] = mean_combo
                    tempResults = mean_combo.to_frame().transpose()
                else:
                    print('* Using Individual results')
                    self.checkBoxSD.setEnabled(False)

                # Check if analysis Paramaters are needed
                if self.checkBoxParameters.isChecked():
                    print('* Using Parameters')
                    tempResultsParams = pd.DataFrame(np.zeros(shape=(len(self.finalResults.index), 2)),
                                                    columns=['ROI', 'Analysis'])
                    tempResultsProps.loc[:, ['ROI']] = self.currentROI.getState()
                    tempResultsProps.loc[:, ['Analysis']] = self.currentAnalysis
                tempResults = pd.concat([tempResultsParams, tempResults], axis=1)

                # Check if video Properties are needed
                if self.checkBoxProperties.isChecked():
                    print('* Using Properties')
                    # tempResultsProps = self.currentResults[['']]
                    tempResultsProps = pd.DataFrame(np.zeros(shape=(len(self.finalResults.index), 3)),
                                                    columns=['Study', 'File', 'ROI'])
                    tempResultsProps.loc[:, ['Study']] = self.currentWindow.study
                    tempResultsProps.loc[:, ['File']] = self.currentWindow.video_name
                    tempResultsProps.loc[:, ['ROI']] = self.currentAnalysis['ROI']

                tempResults = pd.concat([tempResultsProps, tempResults], axis=1)

                self.finalResults = tempResults
                self.tableWidgetResults.setColumnCount(len(self.finalResults.columns))
                self.tableWidgetResults.setRowCount(len(self.finalResults.index))

                for i in range(len(self.finalResults.index)):
                    for j in range(len(self.finalResults.columns)):
                        dataDataFrame = self.finalResults.iat[i, j]
                        try:
                            # Limit all float results to 5 significant digits, due to dt limit
                            float(dataDataFrame)
                            dataTable = str("{0:.5g}".format(dataDataFrame))
                        except ValueError:
                            dataTable = dataDataFrame
                        self.tableWidgetResults.setItem(i, j, QTableWidgetItem(dataTable))
                print('* Results table populated by results dataframe')
                self.tableWidgetResults.setHorizontalHeaderLabels(self.finalResults.columns)
                self.tableWidgetResults.resizeRowsToContents()
                self.tableWidgetResults.resizeColumnsToContents()
            except Exception:
                traceback.print_exc()

            print('** Results loaded!')

    def copyResults(self):
        print('*** copyResults!')
        try:
            print('** copy...')
            selected = self.tableWidgetResults.selectedRanges()
            # s = '\t' + "\t".join([str(self.tableWidgetResults.horizontalHeaderItem(i).text()) for i in
            #                       range(selected[0].leftColumn(), selected[0].rightColumn())])
            s = "\t".join([str(self.tableWidgetResults.horizontalHeaderItem(i).text()) for i in
                           range(selected[0].leftColumn(), selected[0].rightColumn())])
            s = s + '\n'
            for r in range(selected[0].topRow(), selected[0].bottomRow()):
                # s += self.tableWidgetResults.verticalHeaderItem(r).text() + '\t'
                # s += str(self.tableWidgetResults.verticalHeaderItem(r).text()) + '\t'
                for c in range(selected[0].leftColumn(), selected[0].rightColumn()):
                    try:
                        print('** try: s += str(self.table.item(r, c).text()) + "\t"')
                        s += str(self.tableWidgetResults.item(r, c).text()) + "\t"
                    except AttributeError:
                        s += "\t"
                s = s[:-1] + "\n"  # eliminate last '\t'
            self.clip.setText(s)
        except Exception:
            traceback.print_exc()

    def exportResults(self):
        print('*** exportResults!')
        try:
            file_list = [self.currentWindow.study, self.currentWindow.video_name, 'KS']
            file_name = '_'.join(file_list)
            print('** Exporting to ', file_name)
            # File Dialog to generate filename

            # selected = self.tableWidgetResults.selectedRanges()
            # # s = '\t' + "\t".join([str(self.tableWidgetResults.horizontalHeaderItem(i).text()) for i in
            # #                       range(selected[0].leftColumn(), selected[0].rightColumn())])
            # s = "\t".join([str(self.tableWidgetResults.horizontalHeaderItem(i).text()) for i in
            #                range(selected[0].leftColumn(), selected[0].rightColumn())])
            # s = s + '\n'
            # for r in range(selected[0].topRow(), selected[0].bottomRow()):
            #     # s += self.tableWidgetResults.verticalHeaderItem(r).text() + '\t'
            #     # s += str(self.tableWidgetResults.verticalHeaderItem(r).text()) + '\t'
            #     for c in range(selected[0].leftColumn(), selected[0].rightColumn()):
            #         try:
            #             print('** try: s += str(self.table.item(r, c).text()) + "\t"')
            #             s += str(self.tableWidgetResults.item(r, c).text()) + "\t"
            #         except AttributeError:
            #             s += "\t"
            #     s = s[:-1] + "\n"  # eliminate last '\t'
            # self.clip.setText(s)
        except Exception:
            traceback.print_exc()


class PandasModel(QtCore.QAbstractTableModel):
    """
    Class to populate a table view with a pandas dataframe
    """

    def __init__(self, data, parent=None):
        QtCore.QAbstractTableModel.__init__(self, parent)
        self._data = data

    def rowCount(self, parent=None, **kwargs):
        return self._data.shape[0]

    def columnCount(self, parent=None, **kwargs):
        return self._data.shape[1]

    def data(self, index, role=QtCore.Qt.DisplayRole):
        if index.isValid():
            if role == QtCore.Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
        return None

    def headerData(self, col, orientation, role=None):
        if orientation == QtCore.Qt.Horizontal and role == QtCore.Qt.DisplayRole:
            return self._data.columns[col]
        return None


# create the GUI application
app = QApplication(sys.argv)
# instantiate the main window
dmw = DesignerMainWindow()
# show it
dmw.show()
# start the Qt main loop execution, exiting from this script
# with the same return code as the Qt application
sys.exit(app.exec_())
