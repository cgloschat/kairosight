#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import math
import sys
import time
import numpy
from pathlib import Path, PurePath
from random import random
from util.preparation import open_stack
from ui.KairoSight_WindowMDI import Ui_WindowMDI
from ui.KairoSight_WindowMain import Ui_WindowMain
from PyQt5.QtWidgets import QApplication, QWidget, QMainWindow, QFileDialog
from PyQt5.QtGui import QColor


class WindowMDI(QMainWindow, Ui_WindowMDI):
    """Customization for Ui_MDIMainWindow, and MDI main window"""

    def __init__(self, parent=None):
        # initialization of the superclass
        super(WindowMDI, self).__init__(parent)
        # setup the GUI --> function generated by pyuic5
        self.setupUi(self)
        # connect the signals with the slots
        # self.actionLoad.triggered.connect(self.open_tiff)
        # self.actionClose.triggered.connect(self.close)
        self.actionTIFF.triggered.connect(self.open_tiff)

    def open_tiff(self, file=None):
        """Open a WindowMain with a TIFF stack within the MDI area"""
        if file:
            print('Opening tiff with passed filepath: ' + file)
        else:
            # Use a QFileDialog to get filepath if none provided
            file, mask = QFileDialog.getOpenFileName(self, 'Open a .tif/.tiff stack')

        if file:
            self.status_print('Opening ' + file + ' ...')
            f_purepath = PurePath(file)
            f_ext = f_purepath.suffix
            if f_ext == '.pcoraw':
                # Change .pcoraw files to .tif?
                # os.rename(file, f_name + '.tif')
                p = Path(file)
                p.rename(p.with_suffix('.tif'))
                print('* .pcoraw covnerted to a .tif')
                # Use a QFileDialog to get the new filepath
                file, mask = QFileDialog.getOpenFileName(self, 'Open a .tif/.tiff stack')
                self.status_print('Opening ' + file + ' ...')
                f_purepath = PurePath(file)

            f_string = str(f_purepath)
            f_display = str(f_purepath.parent) + '\\' + '\t' + f_purepath.stem + ' ' + f_purepath.suffix
            print('file (path name ext): ' + f_display)
            try:
                # Create QMdiSubWindow with Ui_WidgetTiff
                sub = WindowMain(parent=self, file_path=f_string)
                sub.setObjectName(str(file))
                sub.setWindowTitle('TIFF View: ' + f_display)
                # Add and connect QMdiSubWindow to MDI
                self.mdiArea.addSubWindow(sub)
                sub.show()
                self.statusBar().showMessage('Opened ' + file)
            except Exception:
                exc_type, exc_value = sys.exc_info()[:2]
                self.status_print(' ! ' + str(exc_type) + ' : ' + str(exc_value))
        else:
            print('path is None')
            self.statusBar().showMessage('Open cancelled')

    def status_print(self, text):
        self.statusBar().showMessage(text)


class WindowMain(QWidget, Ui_WindowMain):
    """Customization for Ui_WindowMain"""

    def __init__(self, parent=None, file_path=None):
        super(WindowMain, self).__init__(parent)  # initialization of the superclass
        self.setupUi(self)  # setup the UI
        self.next_buttons = []
        self.setup_next_buttons()

        # Customize Feedback Text
        self.textBrowser_Feedback.setStyleSheet('background: rgb(10, 10, 10)')

        # Import file for this window
        # file_path_local = '/20200228-piga/baseline/05-400_Vm(1031-1280).tif'
        self.file_path = file_path
        self.video_data, self.stack_real_meta = open_stack(source=self.file_path)
        # Flip each frame along the Y-axis (up/down)
        self.frame_n = self.video_data.shape[0]
        for i in range(self.frame_n):
            self.video_data[i] = numpy.flipud(self.video_data[i])
        self.width, self.height = self.video_data.shape[2], self.video_data.shape[1]

        # Setup and connect UI components
        self.horizontalScrollBar.valueChanged['int'].connect(self.update_video)
        self.horizontalScrollBar.setMinimum(1)
        self.horizontalScrollBar.setMaximum(self.frame_n)
        self.lcdNumber_frame_n.display(self.frame_n)
        self.graphicsView.p1.setAspectLocked(True)

        # Set histogram to image levels and use a manual range
        self.graphicsView.histogram.setLevels(self.video_data.min(), self.video_data.max())
        self.graphicsView.histogram.setHistogramRange(self.video_data.min(), self.video_data.max())

    def update_video(self, frame=0):
        """Updates the video frame drawn to the canvas"""
        # Update ImageItem(s) with a frame in a stack
        self.graphicsView.img_item.setImage(self.video_data[frame - 1, ...])
        # Notify histogram items of image change
        self.graphicsView.histogram.regionChanged()

    def apply_prep_step(self, step_button):
        # step_success = True and (random() > 0.5)
        step_name = step_button.accessibleName()
        try:
            fps = int(self.frameRateLineEdit.text())
            self.step_proceed(step_button)
            self.feedback_action('Preparation step {} PASSED'.format(step_name), success=True)
            if step_button is self.buttonNextPrep_Mask:
                self.feedback_action('Preparation STAGE PASSED', success=True)
        except:
            self.reset_progress(step_button)
            # test_error = ' random chance'
            exc_type, exc_value = sys.exc_info()[:2]
            real_error = str(exc_type) + ' : ' + str(exc_value)
            self.feedback_action('Preparation step {} ERROR : {}'
                                 .format(step_name, real_error), success=False)

    def apply_proc_step(self, step_button):
        step_success = True and (random() > 0.5)
        step_name = step_button.accessibleName()
        if step_success:
            self.step_proceed(step_button)
            self.feedback_action('Processing step {} PASSED'.format(step_name), success=step_success)
            if step_button is self.buttonNextPrep_Mask:
                self.feedback_action('Processing STAGE PASSED', success=step_success)
        else:
            self.reset_progress(step_button)
            test_error = ' random chance'
            self.feedback_action('Processing step {} ERROR : {}'
                                 .format(step_name, test_error), success=step_success)

    def apply_analysis_step(self, step_button):
        step_success = True and (random() > 0.5)
        step_name = step_button.accessibleName()
        if step_success:
            self.step_proceed(step_button)
            self.feedback_action('Analysis step {} PASSED'.format(step_name), success=step_success)
            if step_button is self.buttonNextPrep_Mask:
                self.feedback_action('Analysis STAGE PASSED', success=step_success)
        else:
            self.reset_progress(step_button)
            test_error = ' random chance'
            self.feedback_action('Analysis step {} ERROR : {}'
                                 .format(step_name, test_error), success=step_success)

    def feedback_action(self, action_text, success=False):
        time_tuple = time.localtime()
        time_string = '(' + time.strftime("%H:%M:%S", time_tuple) + ') '
        if success:
            self.textBrowser_Feedback.setTextColor(QColor(5, 230, 5))  # green text
        else:
            self.textBrowser_Feedback.setTextColor(QColor(230, 5, 5))  # red text
        self.textBrowser_Feedback.append(time_string + action_text)

    def setup_next_buttons(self):
        self.next_buttons = [self.buttonNextPrep_Props, self.buttonNextPrep_Crop, self.buttonNextPrep_Mask,
                             self.buttonNextProc_Norm, self.buttonNextProc_Filter, self.buttonNextProc_SNR,
                             self.buttonNextAnalysis_Isolate, self.buttonNextAnalysis_Analyze]
        self.buttonNextPrep_Props.released \
            .connect(lambda: self.apply_prep_step(self.buttonNextPrep_Props))
        self.buttonNextPrep_Crop.released \
            .connect(lambda: self.apply_prep_step(self.buttonNextPrep_Crop))
        self.buttonNextPrep_Mask.released \
            .connect(lambda: self.apply_prep_step(self.buttonNextPrep_Mask))
        self.buttonNextProc_Norm.released \
            .connect(lambda: self.apply_proc_step(self.buttonNextProc_Norm))
        self.buttonNextProc_Filter.released \
            .connect(lambda: self.apply_proc_step(self.buttonNextProc_Filter))
        self.buttonNextProc_SNR.released \
            .connect(lambda: self.apply_proc_step(self.buttonNextProc_SNR))
        self.buttonNextAnalysis_Isolate.released \
            .connect(lambda: self.apply_analysis_step(self.buttonNextAnalysis_Isolate))
        self.buttonNextAnalysis_Analyze.released \
            .connect(lambda: self.apply_analysis_step(self.buttonNextAnalysis_Analyze))

    def step_proceed(self, step_button):
        i = 1
        while self.next_buttons[i - 1] is not step_button:
            i += 1
        if i < len(self.next_buttons):
            self.reset_progress(self.next_buttons[i])

    def reset_progress(self, step_button):
        i = 1
        step_button.setEnabled(True)
        while self.next_buttons[i - 1] is not step_button:
            i += 1
        while i < len(self.next_buttons):
            if not self.next_buttons[i].isEnabled():
                break
            self.next_buttons[i].setEnabled(False)
            i += 1


if __name__ == '__main__':
    # create the GUI application
    app = QApplication(sys.argv)
    # instantiate and show the main window
    ks_mdi = WindowMDI()
    ks_mdi.show()
    # start the Qt main loop execution, exiting from this script
    # with the same return code as the Qt application
    sys.exit(app.exec_())
