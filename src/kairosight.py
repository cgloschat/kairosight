#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import json
import os
import sys
import time
import math
import numpy as np
from pathlib import Path, PurePath
from random import random
from util.preparation import open_stack, reduce_stack, mask_generate, mask_apply
from ui.KairoSight_WindowMDI import Ui_WindowMDI
from ui.KairoSight_WindowMain import Ui_WindowMain
from PyQt5.QtCore import QObject, pyqtSignal
from PyQt5.QtWidgets import QApplication, QWidget, QMainWindow, QFileDialog
from PyQt5.QtGui import QColor
import matplotlib.pyplot as plt
import util.ScientificColourMaps5 as SCMaps
from PIL import Image

from util.processing import normalize_stack, filter_spatial


class WindowMDI(QMainWindow, Ui_WindowMDI):
    """Customization for Ui_MDIMainWindow, and MDI main window"""

    def __init__(self, parent=None):
        # initialization of the superclass
        super(WindowMDI, self).__init__(parent)
        # setup the GUI --> function generated by pyuic5
        self.setupUi(self)
        self.raise_()
        # connect the signals with the slots
        # self.actionLoad.triggered.connect(self.open_tiff)
        # self.actionClose.triggered.connect(self.close)
        self.actionTIFF.triggered.connect(self.open_tiff)

    def open_tiff(self, file=None):
        """Open a WindowMain with a TIFF stack within the MDI area"""
        if file:
            print('Opening tiff with passed filepath: ' + file)
        else:
            # Use a QFileDialog to get filepath if none provided
            file, mask = QFileDialog.getOpenFileName(self, 'Open a .tif/.tiff stack')

        if file:
            self.status_print('Opening ' + file + ' ...')
            f_purepath = PurePath(file)
            f_ext = f_purepath.suffix
            if f_ext == '.pcoraw':
                # Change .pcoraw files to .tif?
                # os.rename(file, f_name + '.tif')
                p = Path(file)
                p.rename(p.with_suffix('.tif'))
                print('* .pcoraw covnerted to a .tif')
                # Use a QFileDialog to get the new filepath
                file, mask = QFileDialog.getOpenFileName(self, 'Open a .tif/.tiff stack')
                self.status_print('Opening ' + file + ' ...')
                f_purepath = PurePath(file)

            f_display = str(f_purepath.parent) + '\\' + '\t' + f_purepath.stem + ' ' + f_purepath.suffix
            print('file (path name ext): ' + f_display)
            try:
                # Create QMdiSubWindow with Ui_WidgetTiff
                sub = WindowMain(parent=self, file_purepath=f_purepath)
                sub.setObjectName(str(file))
                sub.setWindowTitle('TIFF View: ' + f_display)
                # Add and connect QMdiSubWindow to MDI
                self.mdiArea.addSubWindow(sub)
                sub.show()
                self.status_print('Opened ' + file)
            except:
                exc_type, exc_value = sys.exc_info()[:2]
                self.status_print('Error ' + str(exc_type) + ' : ' + str(exc_value))
        else:
            print('path is None')
            self.status_print('Open cancelled')

    def status_print(self, text):
        self.statusBar().showMessage(text)


class Stream(QObject):
    newText = pyqtSignal(str)

    def write(self, text):
        self.newText.emit(str(text))


class WindowMain(QWidget, Ui_WindowMain):
    """Customization for Ui_WindowMain"""

    def __init__(self, parent=None, file_purepath=None):
        super(WindowMain, self).__init__(parent)  # initialization of the superclass
        self.WindowMDI = parent
        self.setupUi(self)  # setup the UI
        sys.stdout = Stream(newText=self.feedback_action)
        self.next_buttons = []
        self.setup_next_buttons()
        self.skip_checkboxes = []
        self.setup_skip_buttons()

        # Customize Feedback Text
        self.textBrowser_Feedback.setStyleSheet('background: rgb(10, 10, 10)')

        # Import file for this window
        self.file_purepath = file_purepath
        self.file_path_str = str(self.file_purepath)
        self.project_path_str = str(self.file_purepath.parent) + '\\' + str(self.file_purepath.stem) + '_ks_project'
        self.video_data_raw, self.stack_real_meta = open_stack(source=self.file_path_str)

        # Flip each frame along the Y-axis (up/down)
        self.frame_n = self.video_data_raw.shape[0]
        # for i in range(self.frame_n):
        #     self.video_data_raw[i] = np.flipud(self.video_data_raw[i])
        self.width_raw, self.height_raw = self.video_data_raw.shape[2], self.video_data_raw.shape[1]

        # Copy imported video to preserve it
        self.video_data = self.video_data_raw.copy()
        self.width, self.height = self.video_data.shape[2], self.video_data.shape[1]

        # Setup project directory and files
        self.project_props_prp = {'fps': None, 'scale': None, 'type': None, 'subject': None,
                                  'rescale': 1, 'mask': (None, None)}
        self.project_props_prc = {'norm': None, 'invert': None, 'filter': None, 'snr': None}
        self.project_props_ans = {'d_time': None, 'results': None}
        self.mask = None
        self.setup_project()

        # Setup and connect UI components
        self.kernelPixelsSpinBox.valueChanged.connect(lambda: self.update_inputs(self.kernelPixelsSpinBox))
        self.horizontalScrollBar.valueChanged['int'].connect(self.update_video)
        self.horizontalScrollBar.setMinimum(1)
        self.horizontalScrollBar.setMaximum(self.frame_n)
        self.lcdNumber_frame_n.display(self.frame_n)
        self.graphicsView.p1.setAspectLocked(True)

        # Set histogram to image levels and use a manual range
        self.graphicsView.histogram.setLevels(self.video_data.min(), self.video_data.max())
        self.graphicsView.histogram.setHistogramRange(self.video_data.min(), self.video_data.max())
        self.WindowMDI.status_print('- - -')

    def __del__(self):
        sys.stdout = sys.__stdout__

    def setup_project(self):
        """Create a new or load an existing project folder"""
        try:
            os.mkdir(self.project_path_str)
            self.feedback_action('Project folder created : \\' +
                                 str(self.file_purepath.stem) + '_ks_project\\', success=True)
        except FileExistsError:
            self.feedback_action('Project folder already exists : \\' +
                                 str(self.file_purepath.stem) + '_ks_project\\', success=True)
            # If the project folder already exists, load/create the properties
            try:  # Preparation
                with open(self.project_path_str + '\\' + str(self.file_purepath.stem) + '.ks_prep', 'r') as openfile:
                    self.project_props_prp = json.load(openfile)
                    self.feedback_action('Loaded Preparation properties : ' +
                                         str(self.file_purepath.stem) + '.ks_prep', success=True)
                self.import_parameters()
            except FileNotFoundError:
                with open(self.project_path_str + '\\' + str(self.file_purepath.stem) + '.ks_prep', "w") as outfile:
                    json.dump(self.project_props_prp, outfile)
            try:  # Processing
                with open(self.project_path_str + '\\' + str(self.file_purepath.stem) + '.ks_proc', 'r') as openfile:
                    self.project_props_prc = json.load(openfile)
                    self.feedback_action('Loaded Processing properties : ' +
                                         str(self.file_purepath.stem) + '.ks_proc', success=True)
                self.import_parameters()
            except FileNotFoundError:
                with open(self.project_path_str + '\\' + str(self.file_purepath.stem) + '.ks_proc', "w") as outfile:
                    json.dump(self.project_props_prc, outfile)
            try:  # Analysis
                with open(self.project_path_str + '\\' + str(self.file_purepath.stem) + '.ks_anys', 'r') as openfile:
                    self.project_props_ans = json.load(openfile)
                    self.feedback_action('Loaded Analysis properties : ' +
                                         str(self.file_purepath.stem) + '.ks_anys', success=True)
                self.import_parameters()
            except FileNotFoundError:
                with open(self.project_path_str + '\\' + str(self.file_purepath.stem) + '.ks_anys', "w") as outfile:
                    json.dump(self.project_props_ans, outfile)

    def update_video(self, frame=0):
        """Updates the video frame drawn to the canvas"""
        # Update ImageItem(s) with a frame in a stack
        self.graphicsView.img_item.setImage(self.video_data[frame - 1, ...])
        # Notify histogram items of image change
        self.graphicsView.histogram.regionChanged()

    def update_parameters(self, step_name):
        """Update user parameters with input fields"""
        if step_name == 'Properties':
            try:
                self.project_props_prp['fps'] = float(self.frameRateLineEdit.text())
            except ValueError:
                self.feedback_action('Preparation step {} ERROR : Bad entry in "Frame Rate (fps)",'
                                     ' must be a number (e.g 505.5)'.format(step_name), success=False)
                raise ValueError
            try:
                self.project_props_prp['scale'] = float(self.scaleLineEdit.text())
            except ValueError:
                self.feedback_action('Preparation step {} ERROR : Bad entry in "Scale (px/cm)",'
                                     ' must be a number (e.g 101.4362)'.format(step_name), success=False)
                raise ValueError
            with open(self.project_path_str + '\\' + str(self.file_purepath.stem) + '.ks_prep', "w") as outfile:
                json.dump(self.project_props_prp, outfile)
        elif step_name == 'Crop':
            try:
                self.project_props_prp['rescale'] = int(self.rescaleSpinBox.value())
            except:
                exc_type, exc_value = sys.exc_info()[:2]
                real_error = str(exc_type) + ' : ' + str(exc_value)
                self.feedback_action('Preparation step {} ERROR : {}'.format(step_name, real_error), success=False)
            with open(self.project_path_str + '\\' + str(self.file_purepath.stem) + '.ks_prep', "w") as outfile:
                json.dump(self.project_props_prp, outfile)
        elif step_name == 'Mask':
            try:
                self.project_props_prp['mask'] = (int(self.darkCutoffSpinBox.value()),
                                                  int(self.lightCutoffSpinBox.value()))
            except:
                exc_type, exc_value = sys.exc_info()[:2]
                real_error = str(exc_type) + ' : ' + str(exc_value)
                self.feedback_action('Preparation step {} ERROR : {}'.format(step_name, real_error), success=False)
            with open(self.project_path_str + '\\' + str(self.file_purepath.stem) + '.ks_prep', "w") as outfile:
                json.dump(self.project_props_prp, outfile)
        elif step_name == 'Normalize':
            try:
                self.project_props_prc['norm'] = self.normTypeComboBox.currentText()
            except:
                exc_type, exc_value = sys.exc_info()[:2]
                real_error = str(exc_type) + ' : ' + str(exc_value)
                self.feedback_action('Processing step {} ERROR : {}'.format(step_name, real_error), success=False)
            with open(self.project_path_str + '\\' + str(self.file_purepath.stem) + '.ks_proc', "w") as outfile:
                json.dump(self.project_props_prc, outfile)
        elif step_name == 'Filter':
            try:
                self.project_props_prc['filter'] = int(self.kernelPixelsSpinBox.value())
            except:
                exc_type, exc_value = sys.exc_info()[:2]
                real_error = str(exc_type) + ' : ' + str(exc_value)
                self.feedback_action('Processing step {} ERROR : {}'.format(step_name, real_error), success=False)
            with open(self.project_path_str + '\\' + str(self.file_purepath.stem) + '.ks_proc', "w") as outfile:
                json.dump(self.project_props_prc, outfile)

    def update_inputs(self, field):
        """Update connected user input fields"""
        try:
            if field is self.kernelPixelsSpinBox:
                self.kernelSizeLineEdit.setEnabled(True)
                scale_sig_figfs = len(str(self.project_props_prp['scale']).split(sep='.')[-1])
                kernel_size_cm = np.round(float(self.kernelPixelsSpinBox.value()) / self.project_props_prp['scale'],
                                          scale_sig_figfs)
                self.kernelSizeLineEdit.setText(str(kernel_size_cm))
                self.kernelSizeLineEdit.setEnabled(False)
        except:
            exc_type, exc_value = sys.exc_info()[:2]
            real_error = str(exc_type) + ' : ' + str(exc_value)
            self.feedback_action('Update Input ERROR : {}'.format(real_error), success=False)

    def import_parameters(self):
        """Populate user input fields with imported parameters"""
        if self.project_props_prp['fps']:
            self.frameRateLineEdit.setText(str(self.project_props_prp['fps']))
        if self.project_props_prp['scale']:
            self.scaleLineEdit.setText(str(self.project_props_prp['scale']))
        if self.project_props_prp['mask'][0]:
            self.darkCutoffSpinBox.setValue(int(self.project_props_prp['mask'][0]))
            self.lightCutoffSpinBox.setValue(int(self.project_props_prp['mask'][1]))
        if self.project_props_prc['filter']:
            self.filter.setValue(int(self.project_props_prp['mask'][0]))
        # TODO add prep input fields

    def apply_prep_step(self, step_button):
        step_name = step_button.accessibleName()
        self.feedback_action('Preparation step {} RUNNING ...'.format(step_name), success=True)
        try:
            if step_name == 'Properties':
                # Attempt Props actions
                self.update_parameters(step_name)
            elif step_name == 'Crop':
                # Attempt Crop actions
                self.update_parameters(step_name)
                if self.project_props_prp['rescale'] == 1:
                    self.video_data = self.video_data_raw
                else:
                    self.video_data = reduce_stack(self.video_data_raw, self.project_props_prp['rescale'])
                self.graphicsView.histogram.setLevels(self.video_data.min(), self.video_data.max())
                self.graphicsView.histogram.setHistogramRange(self.video_data.min(), self.video_data.max())
            elif step_name == 'Mask':
                # Attempt Mask actions
                self.update_parameters(step_name)
                strict = (self.project_props_prp['mask'][0], self.project_props_prp['mask'][1])

                fig_mask = plt.figure(figsize=(8, 5))  # _ x _ inch page
                axis_in = fig_mask.add_subplot(131)
                axis_mask = fig_mask.add_subplot(132)
                axis_masked = fig_mask.add_subplot(133)
                # Common between the two
                for ax in [axis_in, axis_mask, axis_masked]:
                    ax.spines['right'].set_visible(False)
                    ax.spines['left'].set_visible(False)
                    ax.spines['top'].set_visible(False)
                    ax.spines['bottom'].set_visible(False)
                    ax.set_yticks([])
                    ax.set_yticklabels([])
                    ax.set_xticks([])
                    ax.set_xticklabels([])
                fig_mask.suptitle(
                    'Masking: {}, strictness:{}\n({})'.format('Random_walk', strict, str(self.file_purepath.stem)))
                axis_in.set_title('Input frame')
                axis_mask.set_title('Markers for\nMask')
                axis_masked.set_title('Masked frame')

                frame_masked, self.mask, markers = mask_generate(self.video_data[0], 'Random_walk', strict)
                cmap_frame = SCMaps.grayC.reversed()
                img_in = axis_in.imshow(self.video_data[0], cmap=cmap_frame)
                img_mask = axis_mask.imshow(markers, cmap='magma')
                img_masked = axis_masked.imshow(frame_masked, cmap=cmap_frame)
                fig_mask.savefig(self.project_path_str + '\\' + 'prep_mask.png')
                self.video_data = mask_apply(self.video_data, self.mask)

        except ValueError:
            self.reset_progress(step_button)
        except:
            self.reset_progress(step_button)
            exc_type, exc_value = sys.exc_info()[:2]
            real_error = str(exc_type) + ' : ' + str(exc_value)
            self.feedback_action('Preparation step {} ERROR : {}'.format(step_name, real_error), success=False)
        else:
            self.step_proceed(step_button)
            self.update_video(frame=self.frame_n)
            self.feedback_action('Preparation step {} PASSED'.format(step_name), success=True)
            if step_button is self.buttonNextPrep_Mask:
                self.feedback_action('Preparation STAGE PASSED', success=True)

    def apply_proc_step(self, step_button):
        step_success = True and (random() > 0.5)
        step_name = step_button.accessibleName()
        self.feedback_action('Processing step {} RUNNING ...'.format(step_name), success=True)
        try:
            if step_name == 'Normalize':
                # Attempt Normalize actions
                self.update_parameters(step_name)
                if self.normTypeComboBox.currentText() == '0 - 1':
                    self.video_data = normalize_stack(self.video_data)
                    self.graphicsView.histogram.setLevels(0, 1)
                    self.graphicsView.histogram.setHistogramRange(-0.5, 1.5)
                    self.update_video()
            elif step_name == 'Filter':
                # Attempt Filter actions
                self.update_parameters(step_name)
                for idx, frame in enumerate(self.video_data):
                    # print('\r\tFrame:\t{}\t/ {}'.format(idx + 1, stack_out.shape[0]), end='', flush=True)
                    frame_filtered = filter_spatial(frame, kernel=self.project_props_prc['filter'])
                    # f_filtered = np.ma.masked_where(f_filtered == 0, f_filtered)
                    self.video_data[idx, :, :] = frame_filtered
                if self.mask is not None:
                    self.video_data = mask_apply(self.video_data, self.mask)
            elif step_name == 'SNR':
                # Attempt SNR actions
                self.update_parameters(step_name)

        except ValueError:
            self.reset_progress(step_button)
        except:
            self.reset_progress(step_button)
            exc_type, exc_value = sys.exc_info()[:2]
            real_error = str(exc_type) + ' : ' + str(exc_value)
            self.feedback_action('Processing step {} ERROR : {}'.format(step_name, real_error), success=False)
        else:
            self.update_video()
            self.step_proceed(step_button)
            self.feedback_action('Processing step {} PASSED'.format(step_name), success=True)
            if step_button is self.buttonNextProc_SNR:
                self.feedback_action('Processing STAGE PASSED', success=True)

    def apply_analysis_step(self, step_button):
        step_success = True and (random() > 0.5)
        step_name = step_button.accessibleName()
        if step_success:
            self.step_proceed(step_button)
            self.feedback_action('Analysis step {} PASSED'.format(step_name), success=step_success)
            if step_button is self.buttonNextAnalysis_Analyze:
                self.feedback_action('Analysis STAGE PASSED', success=step_success)
        else:
            self.reset_progress(step_button)
            test_error = ' random chance'
            self.feedback_action('Analysis step {} ERROR : {}'
                                 .format(step_name, test_error), success=step_success)

    # TODO set parameters to None when skipped
    def skip_prep_step(self, step_checkbox, step_button):
        step_name = step_button.accessibleName()
        if step_checkbox.checkState():
            self.step_proceed(step_button)
            step_button.setEnabled(False)
            self.feedback_action('Preparation step {} SKIPPED'.format(step_name), success=True)
            if step_button is self.buttonNextPrep_Mask:
                self.feedback_action('Preparation STAGE PASSED', success=True)
        else:
            self.reset_progress(step_button)

    def skip_proc_step(self, step_checkbox, step_button):
        step_name = step_button.accessibleName()
        if step_checkbox.checkState():
            self.step_proceed(step_button)
            step_button.setEnabled(False)
            self.feedback_action('Processing step {} SKIPPED'.format(step_name), success=True)
            if step_button is self.buttonNextProc_SNR:
                self.feedback_action('Processing STAGE PASSED', success=True)
        else:
            self.reset_progress(step_button)

    def skip_analysis_step(self, step_checkbox, step_button):
        step_name = step_button.accessibleName()
        if step_checkbox.checkState():
            self.step_proceed(step_button)
            step_button.setEnabled(False)
            self.feedback_action('Analysis step {} SKIPPED'.format(step_name), success=True)
        else:
            self.reset_progress(step_button)

    def feedback_action(self, action_text, success=False):
        time_tuple = time.localtime()
        time_string = '(' + time.strftime("%H:%M:%S", time_tuple) + ') '
        if success:
            self.textBrowser_Feedback.setTextColor(QColor(5, 230, 5))  # green text
        else:
            self.textBrowser_Feedback.setTextColor(QColor(230, 5, 5))  # red text
        self.textBrowser_Feedback.append(time_string + action_text)
        self.textBrowser_Feedback.repaint()

    def setup_next_buttons(self):
        self.next_buttons = [self.buttonNextPrep_Props, self.buttonNextPrep_Crop, self.buttonNextPrep_Mask,
                             self.buttonNextProc_Norm, self.buttonNextProc_Filter, self.buttonNextProc_SNR,
                             self.buttonNextAnalysis_Isolate, self.buttonNextAnalysis_Analyze]
        self.buttonNextPrep_Props.released \
            .connect(lambda: self.apply_prep_step(self.buttonNextPrep_Props))
        self.buttonNextPrep_Crop.released \
            .connect(lambda: self.apply_prep_step(self.buttonNextPrep_Crop))
        self.buttonNextPrep_Mask.released \
            .connect(lambda: self.apply_prep_step(self.buttonNextPrep_Mask))
        self.buttonNextProc_Norm.released \
            .connect(lambda: self.apply_proc_step(self.buttonNextProc_Norm))
        self.buttonNextProc_Filter.released \
            .connect(lambda: self.apply_proc_step(self.buttonNextProc_Filter))
        self.buttonNextProc_SNR.released \
            .connect(lambda: self.apply_proc_step(self.buttonNextProc_SNR))
        self.buttonNextAnalysis_Isolate.released \
            .connect(lambda: self.apply_analysis_step(self.buttonNextAnalysis_Isolate))
        self.buttonNextAnalysis_Analyze.released \
            .connect(lambda: self.apply_analysis_step(self.buttonNextAnalysis_Analyze))

    def setup_skip_buttons(self):
        self.skip_checkboxes = [self.checkBoxSkipPrep_Crop.stateChanged, self.checkBoxSkipPrep_Mask.stateChanged,
                                self.checkBoxSkipProc_Filter.stateChanged, self.checkBoxSkipProc_SNR.stateChanged,
                                self.checkBoxSkipAnalysis_Isolate.stateChanged]
        self.checkBoxSkipPrep_Crop.stateChanged \
            .connect(lambda: self.skip_prep_step(self.checkBoxSkipPrep_Crop, self.buttonNextPrep_Crop))
        self.checkBoxSkipPrep_Mask.stateChanged \
            .connect(lambda: self.skip_prep_step(self.checkBoxSkipPrep_Mask, self.buttonNextPrep_Mask))
        self.checkBoxSkipProc_Filter.stateChanged \
            .connect(lambda: self.skip_proc_step(self.checkBoxSkipProc_Filter, self.buttonNextProc_Filter))
        self.checkBoxSkipProc_SNR.stateChanged \
            .connect(lambda: self.skip_proc_step(self.checkBoxSkipProc_SNR, self.buttonNextProc_SNR))
        self.checkBoxSkipAnalysis_Isolate.stateChanged \
            .connect(lambda: self.skip_analysis_step(self.checkBoxSkipAnalysis_Isolate,
                                                     self.buttonNextAnalysis_Isolate))

    def step_proceed(self, step_button):
        i = 1
        while self.next_buttons[i - 1] is not step_button:
            i += 1
        if i < len(self.next_buttons):
            self.reset_progress(self.next_buttons[i])

    def reset_progress(self, step_button):
        i = 1
        step_button.setEnabled(True)
        if step_button is self.buttonNextPrep_Crop:
            self.checkBoxSkipPrep_Crop.setEnabled(True)
            self.checkBoxSkipPrep_Crop.setChecked(False)
        elif step_button is self.buttonNextPrep_Mask:
            self.checkBoxSkipPrep_Mask.setEnabled(True)
            self.checkBoxSkipPrep_Mask.setChecked(False)
        elif step_button is self.buttonNextProc_Filter:
            self.checkBoxSkipProc_Filter.setEnabled(True)
            self.checkBoxSkipProc_Filter.setChecked(False)
        elif step_button is self.buttonNextProc_SNR:
            self.checkBoxSkipProc_SNR.setEnabled(True)
            self.checkBoxSkipProc_SNR.setChecked(False)
        elif step_button is self.buttonNextAnalysis_Isolate:
            self.checkBoxSkipAnalysis_Isolate.setEnabled(True)
            self.checkBoxSkipAnalysis_Isolate.setChecked(False)
        while self.next_buttons[i - 1] is not step_button:
            i += 1
        while i < len(self.next_buttons):
            cur_button = self.next_buttons[i]
            if not cur_button.isEnabled():
                break
            if cur_button is self.buttonNextPrep_Crop:
                self.checkBoxSkipPrep_Crop.setEnabled(False)
            elif cur_button is self.buttonNextPrep_Mask:
                self.checkBoxSkipPrep_Mask.setEnabled(False)
            elif cur_button is self.buttonNextProc_Filter:
                self.checkBoxSkipProc_Filter.setEnabled(False)
            elif cur_button is self.buttonNextProc_SNR:
                self.checkBoxSkipProc_SNR.setEnabled(False)
            elif cur_button is self.buttonNextAnalysis_Isolate:
                self.checkBoxSkipAnalysis_Isolate.setEnabled(False)
            cur_button.setEnabled(False)
            i += 1


if __name__ == '__main__':
    # create the GUI application
    app = QApplication(sys.argv)
    # instantiate and show the main window
    ks_mdi = WindowMDI()
    ks_mdi.show()
    # start the Qt main loop execution, exiting from this script
    # with the same return code as the Qt application
    sys.exit(app.exec_())
