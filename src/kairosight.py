#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import sys
import traceback
import numpy as np
import pandas as pd
from pathlib import PurePath

import scipy.signal as sig
from PyQt5 import QtCore, QtWidgets
from PyQt5.QtCore import QDir, Qt
from PyQt5.QtGui import QStandardItemModel
from PyQt5.QtWidgets import QApplication, QWidget, QMainWindow, QFileDialog, QFileSystemModel, QDialogButtonBox, \
    QTableWidgetItem, QLabel, QComboBox, QCheckBox
import pyqtgraph as pg
from ui.KairoSightMainMDI import Ui_MDIMainWindow
from ui.KairoSightWidgetTIFFpyqtgraph import Ui_WidgetTiff
from ui.KairoSightWidgetFolderTree import Ui_WidgetFolderTree
from ui.KairoSightWidgetSplit import Ui_WidgetSplit
from ui.KairoSightWidgetIsolate import Ui_WidgetIsolate
from ui.KairoSightWidgetAnalyze import Ui_WidgetAnalyze
from ui.KairoSightWidgetExport import Ui_WidgetExport
from ui.signalwidget import SignalWidget
from algorithms import tifopen, peak_detect, process


class MDIWindow(QMainWindow, Ui_MDIMainWindow):
    """Customization for Ui_MDIMainWindow, and MDI main window"""

    def __init__(self, parent=None):
        # initialization of the superclass
        super(MDIWindow, self).__init__(parent)
        # setup the GUI --> function generated by pyuic5
        self.setupUi(self)
        # connect the signals with the slots
        # self.actionLoad.triggered.connect(self.open_tiff)
        # self.actionClose.triggered.connect(self.close)
        self.actionTIFF.triggered.connect(self.open_tiff)
        self.actionFolder.triggered.connect(self.open_folder)
        self.actionStart_Isolate.triggered.connect(self.isolate)
        self.actionStart_Analyze.triggered.connect(self.analyze)
        self.menuExport.aboutToShow.connect(self.export)

    def open_tiff(self, file=None):
        """Open a SubWindow with a TIFF stack in the main MDI area"""
        if file:
            print('Opening tiff with passed filepath: ' + file)
        else:
            # Use a QFileDialog to get filepath if none provided
            file, mask = QFileDialog.getOpenFileName(self, 'Open a .tif/.tiff stack')

        if file:
            self.statusBar().showMessage('Opening ' + file + ' ...')
            f_purepath = PurePath(file)
            f_path = str(f_purepath.parent) + '/'
            f_dir = f_purepath.parent.parts[-1]
            f_name = f_purepath.stem
            f_ext = f_purepath.suffix
            f_display = f_path + ' ' + f_name + ' ' + f_ext
            print('file (path name ext): ' + f_display)
            if f_ext is '.tif' or '.tiff':
                # print('TIFF chosen')
                # Create QMdiSubWindow with Ui_WidgetTiff
                try:
                    sub = WindowTiff(parent=self, f_path=f_path, f_dir=f_dir, f_name=f_name, f_ext=f_ext)
                    sub.setObjectName(str(file))
                    sub.setWindowTitle('TIFF View: ' + f_display)
                    # Add and connect QMdiSubWindow to MDI
                    self.mdiArea.addSubWindow(sub)
                    # print('"sub" added to MDI')
                    sub.show()
                    self.statusBar().showMessage('Opened ' + file)
                except Exception:
                    traceback.print_exc()
                    ex_type, ex_value, ex_traceback = sys.exc_info()
                    self.statusBar().showMessage('Failed to open, ' + file + ' : ' + str(ex_type))
        else:
            print('path is None')
            self.statusBar().showMessage('Open cancelled')

    def open_folder(self):
        """Open a SubWindow with a folder tree view in the main MDI area"""
        folder_path = QFileDialog.getExistingDirectory(self, 'Choose a folder to view')
        print('Folder chosen! path: ' + folder_path)
        # Create QMdiSubWindow with Ui_WidgetTiff
        sub = WindowFolder(parent=self, root=folder_path)
        print('WindowFolder "sub" created')
        print('Set "sub" widget to "Ui_WidgetFolderTree"')
        sub.setWindowTitle('Folder View: ' + folder_path)
        # Add and connect QMdiSubWindow to MDI
        self.mdiArea.addSubWindow(sub)
        sub.pushButtonOpen.released.connect(lambda: self.open_tiff(sub.currentFilePath))
        print('"sub" added to MDI')
        sub.show()

    def isolate(self):
        """Open the Isolate SubWindow"""
        tiff_windows = []
        # Create a list of all open TIFF subwindows
        for sub in self.mdiArea.subWindowList():
            # print('**' + str(type(sub.widget())) + ', ' + sub.widget().objectName() + ' is a tiff? ')
            if type(sub.widget()) is WindowTiff:
                tiff_windows.append(sub)
        if tiff_windows:
            sub_iso = WindowIsolate(parent=self, w_list=tiff_windows)
            self.mdiArea.addSubWindow(sub_iso)
            sub_iso.show()
        else:
            self.statusBar().showMessage('No processed videos to isolate!')

    def analyze(self):
        """Open the Analyze SubWindow"""
        tiff_windows = []
        # Create a list of all open TIFF subwindows
        for sub in self.mdiArea.subWindowList():
            # print('**' + str(type(sub.widget())) + ', ' + sub.widget().objectName() + ' is a tiff? ')
            if type(sub.widget()) is WindowTiff:
                if sub.widget().ROIs:
                    tiff_windows.append(sub)
        if tiff_windows:
            sub_analyze = WindowAnalyze(parent=self, w_list=tiff_windows)
            self.mdiArea.addSubWindow(sub_analyze)
            sub_analyze.show()
        else:
            self.statusBar().showMessage('No processed videos with ROIs to analyze!')

    def export(self):
        """Open a dialog to copy or export .csv of Analysis results"""
        tiff_windows = []
        # Create a list of all open TIFF subwindows
        for sub in self.mdiArea.subWindowList():
            # print('**' + str(type(sub.widget())) + ', ' + sub.widget().objectName() + ' is a tiff? ')
            if type(sub.widget()) is WindowTiff:
                # if sub.widget().ROIs:
                tiff_windows.append(sub)
        if tiff_windows:
            sub_export = WindowExport(w_list=tiff_windows)
            self.mdiArea.addSubWindow(sub_export)
            sub_export.show()
        else:
            self.statusBar().showMessage('No analyzed ROIs with results to export!')


class WindowTiff(QWidget, Ui_WidgetTiff):
    """Customization for Ui_WidgetTiff subwindow for an MDI"""
    # TODO split and overlay videos (Voltage + Calcium) and use autoregistration, XYCZT
    # TODO build a better data tree for ROIs and Analysis
    INDEX_R, TYPE_R, POSITION, SIZE = range(4)
    INDEX_A, ROI, TYPE_A, ROI_CALC, FRAMES, FILTER, PEAKS = range(7)

    def __init__(self, parent=None, f_path=None, f_dir=None, f_name=None, f_ext=None):
        # Initialization of the superclass
        super(WindowTiff, self).__init__(parent)
        self.MainWindow = parent
        # Setup the GUI
        self.setupUi(self)
        pg.setConfigOptions(background=pg.mkColor(0.1))
        pg.setConfigOptions(foreground=pg.mkColor(0.3))
        # Preserve plot area's aspect ration so image always scales correctly
        self.graphicsView.p1.setAspectLocked(True)
        # Connect the scrollbar's value signal to trigger a video update
        self.horizontalScrollBar.valueChanged['int'].connect(self.updateVideo)

        # Load the video file
        self.video_path = f_path
        self.video_dir = f_dir
        self.video_name = f_name
        self.video_ext = f_ext
        print('* Opening video:', self.video_dir, ' / ', self.video_name, ' ', self.video_ext)
        self.video_file, self.dt = tifopen.tifopen(self.video_path, self.video_name + self.video_ext)
        # print('tifopen finished')
        # get video properties
        self.video_shape = self.video_file.shape
        if len(self.video_shape) < 3:
            raise Exception('TIFF has less than 3 dimensions')
        self.frames = self.video_shape[0]

        # Transpose second and third axes (y, x) to correct orientation (x, y)
        print('* Transposing')
        self.video_data = np.transpose(self.video_file, (0, 2, 1))
        # Flip each frame in the left/right direction, expected to be up/down
        print('* Flipping each frame along x-axis')
        for i in range(self.frames):
            self.video_data[i] = np.fliplr(self.video_data[i])

        # Add an axis to the video data array, in case of video splitting, (signal, time, x, y)
        self.video_data = self.video_data[np.newaxis, ...]
        # Create array of display data
        self.display_data = self.video_data[0]

        # Use a dummy dt (aka Frame Period) if none detected
        # From most MetaMorph videos: exposure time 1.219 ms -> dt = 1.238 ms
        if np.isnan(self.dt):
            self.framePeriodMsLabel.setText('?Frame Period (ms)')
            self.frameRateLabel.setText('?Frame Rate (fps)')
            self.dt = 1.238

        # Limit all float results to 5 significant digits, due to dt limit
        self.dt = float("{0:.5g}".format(self.dt))

        # Set-up Properties fields
        self.subject = self.video_dir  # e.g. 20190418-ratb
        self.fps = 1000 / self.dt
        self.duration = self.dt * self.frames
        self.width, self.height = self.video_shape[2], self.video_shape[1]
        self.resolution = None  # cm/px
        print('video shape:         ', self.video_shape)
        print('Width x Height:      ', self.width, self.height)
        print('# of Frames:         ', self.frames)
        print('Frame Period (ms):   ', self.dt)
        print('FPS:                 ', self.fps)
        print('Duration (ms):       ', self.duration)

        self.SizeLabelEdit.setText(str(self.width) + ' X ' + str(self.height)
                                   + ' [X ' + str(self.frames) + ']')

        self.subjectLineEdit.setText(self.subject)
        self.framePeriodMsLineEdit.setText(str(self.dt))
        self.frameRateLineEdit.setText(str(self.fps))
        self.durationMsLineEdit.setText(str(self.duration))
        self.durationMsLineEdit.setEnabled(False)

        self.subjectLineEdit.editingFinished.connect(lambda: self.updateProperties(param=self.subject))
        self.framePeriodMsLineEdit.editingFinished.connect(lambda: self.updateProperties(param=self.dt))
        self.frameRateLineEdit.editingFinished.connect(lambda: self.updateProperties(param=self.fps))
        self.resolutionLineEdit.editingFinished.connect(lambda: self.updateProperties(param=self.resolution))
        self.updateProperties()

        # Setup Signals data and Signals UI for splitting options
        # TODO use checkboxes for signal stack visibility
        self.Signals = []
        self.SIGNAL_OPTIONS = ['Voltage (Vm)', 'Calcium (Ca)']
        self.pushButtonSignalAdd.pressed.connect(self.splitVideo)
        self.pushButtonSignalRemove.pressed.connect(self.reduceVideo)
        # Add a default signal
        self.addSignal()

        # Setup ROIs and Anlysis data
        self.ROIs = []  # A list of pg.ROI objects
        self.ROIsLabels = []  # A list of pg.ROI object labels
        self.Analysis = []  # A list of Analysis results dictionaries
        self.analysis_default = {'ROI': '0', 'INDEX_A': np.nan, 'TYPE': 'Voltage',
                                 'ROI_CALC': 'Mean', 'FRAMES': '1-XXXX', 'FILTER': '60', 'PEAKS': '0.72,172',
                                 'RESULTS': None}
        # Set scroll bar maximum to number of frames
        self.horizontalScrollBar.setMinimum(1)
        self.horizontalScrollBar.setMaximum(self.frames)
        self.frame_current = 0
        # Set histogram to image levels and use a manual range
        self.graphicsView.histograms[0].setLevels(self.display_data.min(), self.display_data.max())
        self.graphicsView.histograms[0].setHistogramRange(self.display_data.min(), self.display_data.max())

        # Setup data treeviews
        # Calling it a treeview, currently connected to table-like models
        # ROI model
        self.treeViewROIs.setAlternatingRowColors(True)
        self.modelRoi = QStandardItemModel(0, 4)
        self.modelRoi.setHeaderData(self.INDEX_R, Qt.Horizontal, "#")
        self.modelRoi.setHeaderData(self.TYPE_R, Qt.Horizontal, "Type")
        self.modelRoi.setHeaderData(self.POSITION, Qt.Horizontal, "Position (X,Y)")
        self.modelRoi.setHeaderData(self.SIZE, Qt.Horizontal, "Size (px)")
        self.treeViewROIs.setModel(self.modelRoi)
        for idx in range(4):
            self.treeViewROIs.resizeColumnToContents(idx)

        # Analysis model
        self.treeViewAnalysis.setAlternatingRowColors(True)
        self.modelAnalysis = QStandardItemModel(0, 7)
        self.modelAnalysis.setHeaderData(self.INDEX_A, Qt.Horizontal, "#")
        self.modelAnalysis.setHeaderData(self.ROI, Qt.Horizontal, "ROI#")
        self.modelAnalysis.setHeaderData(self.TYPE_A, Qt.Horizontal, "Type")
        self.modelAnalysis.setHeaderData(self.ROI_CALC, Qt.Horizontal, "ROI Calc.")
        self.modelAnalysis.setHeaderData(self.FRAMES, Qt.Horizontal, "Frames")
        self.modelAnalysis.setHeaderData(self.FILTER, Qt.Horizontal, "Filter")
        self.modelAnalysis.setHeaderData(self.PEAKS, Qt.Horizontal, "Peak Det.")
        self.treeViewAnalysis.setModel(self.modelAnalysis)
        for idx in range(7):
            self.treeViewAnalysis.resizeColumnToContents(idx)
        print('WidgetTiff ready')

    def updateProperties(self, param=None):
        """Update TIFF parameters with user-entered/calculated values

            Parameters
            ----------
            param : str, optional
                If specified, the particular parameter changed
            """
        # TODO Invalidate old analysis results when these change?
        print('*** Updating properties')
        # Get text-based params
        self.subject = self.subjectLineEdit.text()
        self.resolution = self.resolutionLineEdit.text()
        # Populate all 'new' params by default
        dt_new = float(self.framePeriodMsLineEdit.text())
        fps_new = float(self.frameRateLineEdit.text())
        # Either use new dt or new fps to calculate the other
        if param is self.dt:
            dt_new = float(self.framePeriodMsLineEdit.text())
            fps_new = 1000 / dt_new
        elif param is self.fps:
            fps_new = float(self.frameRateLineEdit.text())
            dt_new = 1000 / fps_new
        duration_new = dt_new * self.frames

        # Limit Frame Period and Frame Rate to 5 significant figures
        self.dt = float("{0:.5g}".format(dt_new))
        self.fps = float("{0:.5g}".format(fps_new))
        self.duration = float("{0:.5g}".format(duration_new))

        # Update Properties UI elements
        self.framePeriodMsLineEdit.setText(str(self.dt))
        self.frameRateLineEdit.setText(str(self.fps))
        self.durationMsLineEdit.setText(str(self.duration))
        # self.signals = []
        print('** Updated properties')

    def updateVideo(self, frame=0):
        """Updates the video frame drawn to the canvas"""
        # print('Updating video plot in a subWindow with:')
        # print('\n*** Showing ' + self.video_name + '[' + str(frame) + ']')
        # Update ImageItem with a frame in stack
        self.frame_current = frame
        self.graphicsView.stacks[0].setImage(self.display_data[frame - 1])
        # Notify histogram item of image change
        self.graphicsView.histograms[0].regionChanged()

        # Draw ROIs
        # if self.ROIs:
        #     for roi in self.ROIs:
        #         self.graphicsView.p1.addItem(roi)

    def addSignal(self):
        """Splits and aligns a multi-signal video"""
        print('\n*** Adding a Signal')
        idx_new = self.formLayoutSignals.rowCount()
        # idx_new = len(self.signal_ComboBoxes)
        label_new = str(idx_new + 1)
        print('** Signal #' + label_new)
        # self.formLayoutSignals.addRow(QLabel("#" + label_new), QComboBox())
        # self.signal1ComboBox.addItems(self.SIGNAL_OPTIONS)
        print('* Create a SignalWidget')
        new_signal_widget = SignalWidget(self)
        new_signal_widget.comboBoxSignal.addItems(self.SIGNAL_OPTIONS)
        print('* Add the SignalWidget to the form (with label)')
        self.formLayoutSignals.addRow(QLabel(label_new), new_signal_widget)

        if idx_new > 0:
            try:
                print('* Add the new HistogramLUTItem')
                hist_new = pg.HistogramLUTItem()
                # Item for displaying image data
                img = pg.ImageItem()
                self.graphicsView.p1.addItem(img)

                hist_new.setImageItem(img)
                hist_new.vb.setMouseEnabled(y=False)  # makes user interaction a little easier
                self.graphicsView.widget.addItem(hist_new)
                self.graphicsView.histograms.append(hist_new)
            except Exception:
                traceback.print_exc()

        new_signal_widget.comboBoxSignal.currentIndexChanged['int'].connect(self.updateProperties)
        self.Signals.append(new_signal_widget)
        self.pushButtonSignalAdd.setEnabled(True)
        print('** Signals are now: ' + str(self.Signals))

    def splitVideo(self):
        """Splits and aligns a multi-signal video"""
        print('\n*** Splitting current video data')
        try:
            sub_split = WindowSplit(parent=self)
            # main_window = self.MainWindow
            self.MainWindow.mdiArea.addSubWindow(sub_split)
            sub_split.show()
            self.pushButtonSignalAdd.setEnabled(False)
        except Exception:
            traceback.print_exc()
        print('** Split video complete')

    def reduceVideo(self):
        """Reduce the number of signals/videos after splitting"""
        print('\n*** Reducing video')
        # idx_remove = len(self.signal_ComboBoxes)
        # print('** Removing Signal #' + idx_remove)
        # self.formLayoutSignals.removeRow(idx_remove)

    def getRoiPreview(self, roi):
        data = self.display_data[self.frame_current]
        data_img = self.graphicsView.stacks[0]
        data_preview = roi.getArrayRegion(data, data_img)
        return data_preview

    def getRoiStack(self, roi, start_idx=None, end_idx=None):
        data_stack = []
        for idx, frame in enumerate(self.display_data):
            data_img = self.graphicsView.stacks[0]
            data_roi_frame = roi.getArrayRegion(frame, data_img)
            data_roi_frame[data_roi_frame == 0] = np.nan
            data_stack.append(data_roi_frame)
        if (start_idx or end_idx) is not None:
            if not start_idx:
                return data_stack[:end_idx]
            if not end_idx:
                return data_stack[start_idx:]
            return data_stack[start_idx:end_idx]
        else:
            return data_stack

    def addROI(self, idx=None, roi=None):
        print('\n*** addROI: idx:', idx, ' roi:', roi)
        if roi:
            print('* ROIs were: ', self.ROIs)
            roi.translatable = False
            roi_state = roi.getState()
            x, y = str(int(roi_state['pos'].x())), str(int(roi_state['pos'].y()))
            position = x + ',' + y
            r = int(roi_state['size'][0])

            if idx is not None:
                roi_current = self.ROIs[idx]
                label_current = self.ROIsLabels[idx]
                print('** Changing existing ROI from: ', roi_current)
                print('**                              to: ', roi)
                roi_current.setState(roi_state)
                roi_current.setPen(color='54FF00')
                label_current.setPos(int(x), int(y))
            else:
                print('** Adding passed ROI: ', roi)
                length = self.modelRoi.rowCount()
                idx = length
                self.modelRoi.insertRow(idx)
                roi_new = pg.CircleROI([x, y], [r, r], pen=(2, 9), movable=False)
                roi_new.setPen(color='54FF00')
                self.graphicsView.p1.addItem(roi_new)
                self.ROIs.append(roi_new)
                roi_new.removeHandle(0)
                label = pg.TextItem('#' + str(idx))
                label.setPos(int(x), int(y))
                label.setColor(color='54FF00')
                self.graphicsView.p1.addItem(label)
                self.ROIsLabels.append(label)

            self.modelRoi.setData(self.modelRoi.index(idx, self.INDEX_R), idx)
            self.modelRoi.setData(self.modelRoi.index(idx, self.TYPE_R), 'Circle')
            self.modelRoi.setData(self.modelRoi.index(idx, self.POSITION), position)
            self.modelRoi.setData(self.modelRoi.index(idx, self.SIZE), r)
            for idx in range(4):
                self.treeViewROIs.resizeColumnToContents(idx)
            # print('* ROIs are now: ', self.ROIs)
        else:
            print('** No ROI to add!')

    def removeROI(self, idx=None, roi=None):
        if roi:
            try:
                print('** Removing passed ROI: ', roi)
                rois_new = [j for i, j in enumerate(self.ROIs) if i not in [idx]]
                self.modelRoi.removeRow(idx)
                self.graphicsView.p1.removeItem(roi)
                self.ROIs = rois_new

                labels_new = [j for i, j in enumerate(self.ROIsLabels) if i not in [idx]]
                self.graphicsView.p1.removeItem(self.ROIsLabels[idx])
                self.ROIsLabels = labels_new
                for idx in range(4):
                    self.treeViewROIs.resizeColumnToContents(idx)
            except Exception:
                traceback.print_exc()
        else:
            print('** No ROI to remove!')

    def addAnalysis(self, idx=None, analysis=None):
        if analysis:
            print('\n*** addAnalysis: idx:', idx, ' analysis:', analysis)
            roi = analysis['ROI']
            analysis_type = analysis['TYPE']
            roi_calc = analysis['ROI_CALC']
            frames = analysis['FRAMES']
            analysis_filter = analysis['FILTER']
            peaks = analysis['PEAKS']
            if idx is not None:
                analysis_current = self.Analysis[idx]
                print('** Changing existing Analysis from: ', analysis_current)
                print('**                              to: ', analysis)
                analysis['INDEX_A'] = idx
                self.Analysis[idx] = analysis.copy()
            else:
                print('** Adding passed Analysis: ', analysis)
                length = self.modelAnalysis.rowCount()
                idx = length
                analysis['INDEX_A'] = idx
                self.Analysis.append(analysis.copy())
                self.modelAnalysis.insertRow(idx)

            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.INDEX_A), str(idx))
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.ROI), roi)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.TYPE_A), analysis_type)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.ROI_CALC), roi_calc)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.FRAMES), frames)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.FILTER), analysis_filter)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.PEAKS), peaks)
            for idx in range(7):
                self.treeViewAnalysis.resizeColumnToContents(idx)
        else:
            print('** No Analysis to add!')

    def removeAnalysis(self, idx=None, analysis=None):
        if analysis:
            print('* Removing passed Analysis: ', analysis)
            analysis_new = [j for i, j in enumerate(self.Analysis) if i not in [idx]]
            self.Analysis = analysis_new
            self.modelAnalysis.removeRow(idx)
            for idx in range(7):
                self.treeViewAnalysis.resizeColumnToContents(idx)
        else:
            print('* No Analysis to remove!')


class WindowFolder(QWidget, Ui_WidgetFolderTree):
    """Customization for Ui_WidgetFolderTree subwindow for an MDI"""

    def __init__(self, parent=None, root=None):
        # initialization of the superclass
        super(WindowFolder, self).__init__(parent)
        self.dir = QDir(root)
        self.currentFileName = ''
        self.currentFilePath = ''
        # setup the GUI
        self.setupUi(self)
        print('WidgetFolderTree UI setup')
        self.model = QFileSystemModel()
        self.model.setRootPath(root)
        self.treeView.setModel(self.model)
        self.treeView.setRootIndex(self.model.index(root))
        print('treeView ready')

    @QtCore.pyqtSlot(QtCore.QModelIndex)
    def on_treeView_clicked(self, index):
        index_item = self.model.index(index.row(), 0, index.parent())
        self.currentFileName = self.model.fileName(index_item)
        self.currentFilePath = self.model.filePath(index_item)
        print('Clicked: ' + self.currentFilePath + ' ' + self.currentFileName)


class WindowSplit(QWidget, Ui_WidgetSplit):
    """Customization for Ui_WidgetSplit subwindow for an MDI"""

    def __init__(self, parent=None):
        # initialization of the superclass
        super(WindowSplit, self).__init__(parent)

        print('Creating WidgetSplit')
        self.currentWindow = parent
        self.currentPlot = self.currentWindow.graphicsView.p1
        # Create preview ROIs
        # TODO Create with no scale handle
        self.roi_A = pg.RectROI([0, 0], [0, 0])
        self.roi_A.setPen(color='54FF00')
        self.roi_B = pg.RectROI([0, 0], [0, 0])
        self.roi_B.setPen(color='FF000A')
        self.currentPlot.addItem(self.roi_A)
        self.currentPlot.addItem(self.roi_B)

        print('WidgetSplit UI setup...')
        self.setupUi(self)

        self.lockDimensionsCheckBox.stateChanged.connect(self.updateParameters)

        self.originXSpinBoxSignalA.valueChanged.connect(self.updateParameters)
        self.originYSpinBoxSignalA.valueChanged.connect(self.updateParameters)
        self.heightSpinBoxSignalA.valueChanged.connect(self.updateParameters)
        self.heightSpinBoxSignalA.valueChanged.connect(self.updateParameters)

        self.originXSpinBoxSignalB.valueChanged.connect(self.updateParameters)
        self.originYSpinBoxSignalB.valueChanged.connect(self.updateParameters)
        self.heightSpinBoxSignalB.valueChanged.connect(self.updateParameters)
        self.heightSpinBoxSignalB.valueChanged.connect(self.updateParameters)

        self.lockDimensionsCheckBox.stateChanged.connect(self.updateParameters)
        self.buttonBox.button(QDialogButtonBox.RestoreDefaults).clicked.connect(self.loadDefaults)
        self.buttonBox.button(QDialogButtonBox.Apply).clicked.connect(self.applySplit)
        self.loadDefaults()

        print('WidgetSplit ready')

    def closeEvent(self, event):
        """Reimplementation of QWidget.closeEvent

        Parameters
        ----------
        event : PySide2.QtGui.QCloseEvent
            Event when Qt receives a window close request for a top-level widget from the window system
        """
        # for roi in self.currentWindow.ROIs:
        #     roi.setPen(color='54FF00')
        # self.checkBoxPreview.setChecked(False)

        # Remove preview ROIs

        self.currentPlot.removeItem(self.roi_A)
        self.currentPlot.removeItem(self.roi_B)
        self.currentWindow.pushButtonSignalAdd.setEnabled(True)
        event.accept()

    def loadDefaults(self):
        """Populate Split parameter inputs with default values"""
        print('** Loading defaults')
        w, h = int(self.currentWindow.width / 2), int(self.currentWindow.height)
        w_A, h_A = 384, int(self.currentWindow.height)
        x_A, y_A = 0, 0
        x_B, y_B = w_A + (w - w_A), y_A
        # Populate fields with default values
        self.originXSpinBoxSignalA.setValue(x_A)
        self.originYSpinBoxSignalA.setValue(y_A)
        self.widthSpinBoxSignalA.setValue(w_A)
        self.heightSpinBoxSignalA.setValue(h_A)

        self.originXSpinBoxSignalB.setValue(x_B)
        self.originYSpinBoxSignalB.setValue(y_B)

        self.lockDimensionsCheckBox.setChecked(True)
        self.updateParameters()

    def updateParameters(self):
        """Update Split parameter inputs and UI elements"""
        print('** Updating parameters')
        x_A, y_A = self.originXSpinBoxSignalA.value(), self.originYSpinBoxSignalA.value()
        w_A, h_A = self.widthSpinBoxSignalA.value(), self.heightSpinBoxSignalA.value()
        x_B, y_B = self.originXSpinBoxSignalB.value(), self.originYSpinBoxSignalB.value()
        w_B, h_B = self.widthSpinBoxSignalB.value(), self.heightSpinBoxSignalB.value()
        # r = int(roi_state['size'][0])
        # print("Updating roi params with: ", x, ' ', y, ' ', r)
        # Populate fields with passed values
        if self.lockDimensionsCheckBox.isChecked():
            self.widthSpinBoxSignalB.setValue(w_A)
            self.widthSpinBoxSignalB.setEnabled(False)
            self.heightSpinBoxSignalB.setValue(h_A)
            self.heightSpinBoxSignalB.setEnabled(False)
        else:
            # self.widthSpinBoxSignalB.setValue(w_B)
            self.widthSpinBoxSignalB.setEnabled(True)
            # self.heightSpinBoxSignalB.setValue(h_B)
            self.heightSpinBoxSignalB.setEnabled(True)
        self.updateROIs()

    def updateROIs(self):
        x_A, y_A = self.originXSpinBoxSignalA.value(), self.originYSpinBoxSignalA.value()
        w_A, h_A = self.widthSpinBoxSignalA.value(), self.heightSpinBoxSignalA.value()
        x_B, y_B = self.originXSpinBoxSignalB.value(), self.originYSpinBoxSignalB.value()
        w_B, h_B = self.widthSpinBoxSignalB.value(), self.heightSpinBoxSignalB.value()
        self.roi_A.setPos([x_A, y_A])
        self.roi_A.setSize([w_A, h_A])
        self.roi_B.setPos([x_B, y_B])
        self.roi_B.setSize([w_B, h_B])

    def applySplit(self):
        print('\n*** Applying Split')
        print('** Calculating split data arrays stacks')
        print('** Image registration using first frame ')
        print('** ... ')
        self.currentWindow.addSignal()
        self.close()


class WindowIsolate(QWidget, Ui_WidgetIsolate):
    """Customization for Ui_WidgetIsolate subwindow for an MDI"""

    # TODO FIX crash when applying to two sources
    # TODO Detect isolation of split/auto-registered video
    # TODO move *NEW* combobox items to the ends, rather than the beginnings

    def __init__(self, parent=None, w_list=None):
        # initialization of the superclass
        super(WindowIsolate, self).__init__(parent)
        print('Creating WidgetIsolate')
        self.windowList = w_list
        self.currentFileName = ''
        self.currentFilePath = ''
        self.windowDict = {}  # Dictionary with structure "window_name_short": "window"
        name_limit = 50
        for w in self.windowList:
            w_name = w.widget().objectName()
            w_name_short = '..' + w_name[-name_limit:] if len(w_name) > name_limit else w_name
            # Populate dictionary
            self.windowDict[w_name_short] = w.widget()
        self.currentWindow = None
        self.currentPlot = None
        self.currentROIs = []
        self.roi_preview = None
        self.condition_results = None
        # setup the GUI
        print('WidgetIsolate UI setup...')
        self.setupUi(self)
        # Setup preview plot in isolate subwindow
        # TODO remove border around preview, maybe switch to:
        #         self.rawImg = RawImageWidget(QWidget())
        w_preview = self.widgetPreview.addLayout(row=0, col=0)
        self.v_preview = w_preview.addViewBox(lockAspect=True)
        self.img_preview = pg.ImageItem()
        self.v_preview.addItem(self.img_preview)
        self.v_preview.disableAutoRange('xy')
        self.v_preview.autoRange()
        self.plot_preview = self.widgetPreviewPlot.addPlot()

        self.comboBoxSource.addItems(self.windowDict.keys())
        self.comboBoxSource.currentIndexChanged['int'].connect(self.selectionMadeSource)
        self.comboBoxROIs.currentIndexChanged['int'].connect(self.selectionMadeROI)

        self.buttonBox.button(QDialogButtonBox.RestoreDefaults).clicked.connect(self.loadDefaults)
        self.buttonBox.button(QDialogButtonBox.Apply).clicked.connect(self.applyROI)
        self.buttonBox.button(QDialogButtonBox.Discard).clicked.connect(self.discardROI)
        self.checkBoxPreview.stateChanged.connect(self.checkBoxChangedPreview)
        self.buttonBox.button(QDialogButtonBox.Apply).setEnabled(True)
        self.selectionMadeSource(0)

        print('WidgetIsolate ready')

    def closeEvent(self, event):
        """Reimplementation of QWidget.closeEvent

        Parameters
        ----------
        event : PySide2.QtGui.QCloseEvent
            Event when Qt receives a window close request for a top-level widget from the window system
        """
        for roi in self.currentWindow.ROIs:
            roi.setPen(color='54FF00')
        self.checkBoxPreview.setChecked(False)
        event.accept()

    def selectionMadeSource(self, i):
        """Slot for comboBoxSource.currentIndexChanged"""
        print('** selection made in a ', type(self))
        print('* Current Source: ', i, ', ', self.comboBoxSource.currentText())
        self.currentWindow = self.windowDict[self.comboBoxSource.currentText()]
        self.currentPlot = self.currentWindow.graphicsView.p1

        self.currentROIs = self.currentWindow.ROIs
        self.comboBoxROIs.clear()
        self.comboBoxROIs.addItem('*New*')
        for idx, roi in enumerate(self.currentROIs):
            self.comboBoxROIs.addItem(str(idx) + ': ' + str(roi.saveState()))
            print('Listing ROI #', idx, ': ', roi)

        print('* Window: ', str(self.currentWindow))
        print('* W x H: ', str(self.currentWindow.width), ' X ', str(self.currentWindow.height))
        print('* ROIs: ', str(self.currentROIs))
        self.loadDefaults()

    def selectionMadeROI(self, i):
        """Slot for comboBoxROIs.currentIndexChanged"""
        print('** selection made in a ', type(self))
        print('* Current ROI: #', i, ': ', self.comboBoxROIs.currentText())
        for roi in self.currentWindow.ROIs:
            roi.setPen(color='54FF00')
        index_current = self.comboBoxROIs.currentIndex()
        if index_current > 0:
            # An existing ROI has been selected
            # self.checkBoxPreview.setChecked(False)
            roi_current = self.currentWindow.ROIs[index_current - 1]
            print('* ROI #', index_current - 1, ': ', str(roi_current))
            roi_current.setPen(color='FF000A')
            # self.roi_preview = roi_current
            self.updateParameters(roi_current)
        else:
            # *NEW* has been selected
            print('* ROI NEW selected')
            self.loadDefaults()
            self.checkBoxPreview.setChecked(True)

    def loadDefaults(self):
        """Populate ROI parameter inputs with default values"""
        print('** Loading defaults')
        default_r = 15
        # Populate fields with default values
        self.originXLineEdit.setText(str(int(self.currentWindow.width / 2)))
        self.originYLineEdit.setText(str(int(self.currentWindow.height / 2)))
        self.radiusSpinBox.setValue(default_r)

    def updateParameters(self, roi):
        """Populate ROI parameter inputs with an existing ROI's parameters"""
        roi_state = roi.getState()
        x, y = str(int(roi_state['pos'].x())), str(int(roi_state['pos'].y()))
        r = int(roi_state['size'][0])
        # print("Updating roi params with: ", x, ' ', y, ' ', r)
        # Populate fields with passed values
        self.originXLineEdit.setText(x)
        self.originYLineEdit.setText(y)
        self.radiusSpinBox.setValue(r)

    def checkBoxChangedPreview(self):
        """Create/destroy preview ROI and read parameter entries"""
        print('\n*** checkBoxChangedPreview')
        if self.checkBoxPreview.isChecked():
            try:
                if not self.roi_preview:
                    # Get current ROI values
                    print('* checkBoxChangedPreview_1')
                    x, y = int(self.originXLineEdit.text()), int(self.originYLineEdit.text())
                    r = self.radiusSpinBox.value()
                    # Create preview ROI if it doesn't exist
                    print('* checkBoxChangedPreview_2')
                    self.roi_preview = pg.CircleROI([x, y], [r, r], pen=(2, 9), scaleSnap=True, translateSnap=True)
                    self.roi_preview.setPen(color='FF8700')
                    # Draw region on current tiff window's plot
                    print('* checkBoxChangedPreview_3')
                    self.currentPlot.addItem(self.roi_preview)
                    self.roi_preview.sigRegionChanged.connect(self.updatePreviewImage)
                    self.roi_preview.sigRegionChangeFinished.connect(lambda: self.updateParameters(self.roi_preview))
                    # self.roi_preview.sigRegionChanged.connect(lambda: self.updateParameters(self.roi_preview))
                    # self.roi_preview.sigRegionChangeFinished.connect(self.updatePreviewPlot)

                    self.originXLineEdit.textEdited.connect(self.updatePreviewROI)
                    self.originYLineEdit.textEdited.connect(self.updatePreviewROI)
                    self.radiusSpinBox.valueChanged.connect(self.updatePreviewROI)
                    self.updatePreviewROI()
                    # self.updatePreviewPlot()
                    print('** Created preview ROI')
            except Exception:
                traceback.print_exc()
        else:
            # Remove preview ROI
            try:
                print('* checkBoxChangedPreview_remove')
                self.currentPlot.removeItem(self.roi_preview)
                self.roi_preview = None
                self.buttonBox.button(QDialogButtonBox.Apply).setEnabled(False)
                print('** Removed preview ROI')
            except Exception:
                traceback.print_exc()

    def updatePreviewROI(self):
        """Update ROI preview in Isolate subwindow"""
        print('\n*** updatePreviewROI')
        if self.roi_preview:
            # ROI Preview exists, update the params
            # Get current ROI values
            x, y = int(self.originXLineEdit.text()), int(self.originYLineEdit.text())
            r = self.radiusSpinBox.value()
            self.roi_preview.setPos((x, y))
            self.roi_preview.setSize(r)
            #
            # self.updatePreviewImage()
            print('** Updated ROI preview')
        else:
            print('** No ROI preview to update, clearing!')

    def updatePreviewImage(self):
        """Update ROI preview image in Isolate subwindow"""
        print('\n*** updatePreviewImage')
        if self.roi_preview:
            # Get current video frame data and preview ROI data
            data_frame = self.currentWindow.display_data[self.currentWindow.frame_current]
            data_preview = self.currentWindow.getRoiPreview(self.roi_preview)

            # self.roi_preview.setParentItem(img_preview)
            # Draw preview data in isolate subwindow
            self.img_preview.setImage(data_preview, levels=(0, data_frame.max()))
            self.v_preview.autoRange()
            self.buttonBox.button(QDialogButtonBox.Apply).setEnabled(True)
            print('** Set ROI preview image')
        else:
            self.v_preview.clear()
            print('** No ROI preview image to update, clearing!')

    def updatePreviewPlot(self):
        """Update ROI preview plot in Isolate subwindow"""
        print('\n*** updatePreviewPlot')
        if self.roi_preview:
            # Calculate conditioned ROI data across all frames
            print('* Calculating ROI mean')
            roi_data = self.currentWindow.getRoiStack(self.roi_preview)
            roi_data_mean = np.zeros(self.currentWindow.frames)
            for idx, frame in enumerate(roi_data):
                roi_data_mean[idx] = np.nanmean(frame)
            roi_data_mean_norm = np.copy(roi_data_mean)
            norm_MIN = roi_data_mean_norm.min()
            norm_MAX = roi_data_mean_norm.max()
            roi_data_mean_norm = (roi_data_mean_norm - norm_MIN) / (norm_MAX - norm_MIN)
            # if 'Voltage' in self.analysis_preview['TYPE']:
            # roi_data_mean_norm = 1 - roi_data_mean_norm
            print('* ROI mean calculated')
            self.condition_results = roi_data_mean_norm
            # Plot conditioned signal
            self.plot_preview.plot(self.condition_results, clear=True)
            print('** Set ROI preview plot')
        else:
            self.plot_preview.clear()
            print('** No ROI preview plot to update, clearing!')

    def applyROI(self):
        """Add an ROI to a TIFF or applies changes to an existing ROI"""
        if not self.roi_preview:
            print('\n*** No roi_preview to add or edit with')
            return
        else:
            # Add or update the ROI
            if self.comboBoxROIs.currentIndex() is 0:
                # Add the preview ROI to the current TIFF window
                print('\n*** Applying *NEW* ROI ')
                self.currentWindow.addROI(roi=self.roi_preview)
            else:
                # Set state of the chosen ROI (current list index - 1, due to *NEW* at index 0)
                idx_roi = self.comboBoxROIs.currentIndex() - 1
                print('\n*** Changing ROI #' + str(idx_roi))
                roi_current = self.currentROIs[idx_roi]
                self.currentWindow.addROI(idx=idx_roi, roi=self.roi_preview)
                roi_current.setPen(color='54FF00')
            self.checkBoxPreview.setChecked(False)
            self.selectionMadeSource(0)

    def discardROI(self):
        """Remove an existing ROI from an open TIFF"""
        print('\n*** Discarding ROI')
        if self.comboBoxROIs.currentIndex() is 0:
            print('\n*** Cannot discard *NEW* ROI!')
        else:
            if len(self.currentROIs) < 1:
                print('\n*** No ROIs to discard!')
            else:
                print('** Removing ROI: ', self.comboBoxROIs.currentText())
                idx_roi = self.comboBoxROIs.currentIndex() - 1
                roi_current = self.currentROIs[idx_roi]

                self.currentWindow.removeROI(idx=idx_roi, roi=roi_current)
                self.checkBoxPreview.setChecked(False)
                self.selectionMadeSource(0)


class WindowAnalyze(QWidget, Ui_WidgetAnalyze):
    """Customization for Ui_WidgetAnalyze subwindow for an MDI"""

    # TODO clean up Apply and OK UI flow
    # TODO ADD export trace as .csv feature to Condition Tab

    def __init__(self, parent=None, w_list=None):
        # initialization of the superclass
        super(WindowAnalyze, self).__init__(parent)
        print('Creating WidgetAnalyze')
        self.windowList = w_list
        self.currentFileName = ''
        self.currentFilePath = ''
        self.windowDict = {}  # Dictionary with structure "window_name_short": "window"
        name_limit = 50
        for w in self.windowList:
            w_name = w.widget().objectName()
            w_name_short = '..' + w_name[-name_limit:] if len(w_name) > name_limit else w_name
            # Populate dictionary
            self.windowDict[w_name_short] = w.widget()
        self.currentWindow = None
        self.currentVideoPlot = None
        self.currentROIs = []
        self.currentAnalysis = []
        self.roi_current = None
        self.analysis_preview = None
        self.frame_start, self.frame_end = None, None
        self.condition_results = None
        self.peak_results = None
        self.process_results = None

        # setup the GUI
        print('WidgetAnalyze UI setup...')
        self.setupUi(self)
        self.plot_preview = self.widgetPreview.addPlot()
        self.checkBoxTimeAll.stateChanged.connect(self.checkBoxChangedTimeAll)
        self.groupBoxFilter.toggled.connect(self.filterCheckBoxChanged)
        self.tabCondition.setEnabled(False)
        self.tabPeakDetect.setEnabled(False)
        self.tabProcess.setEnabled(False)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)

        self.comboBoxSource.addItems(self.windowDict.keys())
        self.comboBoxSource.currentIndexChanged['int'].connect(self.selectionMadeSource)
        self.comboBoxROIs.currentIndexChanged['int'].connect(self.selectionMadeROI)
        self.comboBoxAnalysis.currentIndexChanged['int'].connect(self.selectionMadeAnalysis)

        self.buttonBoxTimeSlice.button(QDialogButtonBox.Apply).clicked.connect(self.applyTimeSlice)
        self.buttonBoxCondition.button(QDialogButtonBox.Apply).clicked.connect(self.applyCondition)
        self.pushButtonExportTrace.clicked.connect(self.exportTrace)
        self.buttonBoxPeakDetect.button(QDialogButtonBox.Apply).clicked.connect(self.applyPeakDetect)
        self.buttonBoxProcess.button(QDialogButtonBox.Apply).clicked.connect(self.applyProcess)

        self.buttonBoxAnalyze.button(QDialogButtonBox.RestoreDefaults).clicked.connect(self.loadDefaults)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).clicked.connect(self.applyAnalysis)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Discard).clicked.connect(self.discardAnalysis)
        self.progressBar.setValue(0)
        self.selectionMadeSource(0)

        self.startSpinBox.setMaximum(self.currentWindow.frames)
        self.endSpinBox.setMaximum(self.currentWindow.frames)
        self.endSpinBox.setValue(self.currentWindow.frames)
        self.checkBoxTimeAll.setChecked(True)
        # self.listWidgetOpenTiffs.addItems(self.windowListNames)
        print('WidgetAnalyze ready')

    def closeEvent(self, event):
        """Reimplementation of QWidget.closeEvent

        Parameters
        ----------
        event : PySide2.QtGui.QCloseEvent
            Event when Qt receives a window close request for a top-level widget from the window system
        """
        for roi in self.currentWindow.ROIs:
            roi.setPen(color='54FF00')
        event.accept()

    def selectionMadeSource(self, i):
        """Slot for comboBoxSource.currentIndexChanged"""
        print('\n*** selection #', i, ' made in a ', type(self))
        print('* Current Source: ', self.comboBoxSource.currentText())
        self.currentWindow = self.windowDict[self.comboBoxSource.currentText()]
        self.currentVideoPlot = self.currentWindow.graphicsView.p1

        self.comboBoxROIs.clear()
        self.currentROIs = self.currentWindow.ROIs
        for idx, roi in enumerate(self.currentROIs):
            self.comboBoxROIs.addItem(str(idx) + ': ' + str(roi.saveState()))
            print('Listing ROI #', idx, ': ', roi)

        self.comboBoxAnalysis.clear()
        self.currentAnalysis = self.currentWindow.Analysis
        self.comboBoxAnalysis.addItem('*New*')
        for idx, analysis in enumerate(self.currentAnalysis):
            analysis_display = '#' + str(idx) + ': ' + analysis['TYPE']
            self.comboBoxAnalysis.addItem(str(idx) + ': ' + analysis_display)
            print('Listing Analysis #', idx, ': ', analysis_display)

        print('* Window: ', str(self.currentWindow))
        print('* W x H: ', str(self.currentWindow.width), ' X ', str(self.currentWindow.height))
        print('* ROIs: ', str(self.currentROIs))
        print('* Analysis: ', str(self.currentAnalysis))
        # self.loadDefaults()

    def selectionMadeROI(self, i):
        """Slot for comboBoxROIs.currentIndexChanged"""
        print('\n*** selection #', i, ' made in a ', type(self))
        print('** Current ROI: ', self.comboBoxROIs.currentText())
        for roi in self.currentWindow.ROIs:
            roi.setPen(color='54FF00')
        index_current = self.comboBoxROIs.currentIndex()
        # An existing ROI has been selected
        self.roi_current = self.currentWindow.ROIs[index_current]
        print('* ROI: ', str(self.roi_current))
        self.roi_current.setPen(color='FF000A')
        self.progressBar.setValue(20)

    def selectionMadeAnalysis(self, i):
        """Slot for comboBoxAnalysis.currentIndexChanged"""
        print('\n*** selection #', i, ' made in a ', type(self))
        print('** Current Analysis: ', self.comboBoxAnalysis.currentText())
        index_current = self.comboBoxAnalysis.currentIndex()
        if index_current > 0:
            # An existing Analysis has been selected
            self.analysis_preview = self.currentWindow.Analysis[index_current - 1]
            print('* Analysis #', index_current - 1, ': ', str(self.analysis_preview))
            self.updateParameters(self.analysis_preview)
        else:
            # *NEW* has been selected
            self.loadDefaults()

    def loadDefaults(self):
        """Populate Analysis parameter inputs with default values"""
        print('** Load defaults!')
        self.analysis_preview = self.currentWindow.analysis_default.copy()
        self.updateParameters(self.currentWindow.analysis_default)
        if self.tabProcess.isEnabled():
            self.tabProcess.setEnabled(False)
            self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
        if self.tabPeakDetect.isEnabled():
            self.tabPeakDetect.setEnabled(False)
        if self.tabCondition.isEnabled():
            self.tabCondition.setEnabled(False)
        self.plot_preview.clear()
        self.progressBar.setValue(20)
        self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabTimeSlice)

    def updateParameters(self, analysis):
        """Populate Analysis parameter inputs with an existing Analysis's parameters"""
        print('** Updating Analysis parameters')
        roi = analysis['ROI']
        start, end = analysis['FRAMES'].split('-')
        analysis_type = analysis['TYPE']
        roi_calc = analysis['ROI_CALC']
        analysis_filter = analysis['FILTER']
        peaks_thresh, peaks_lockout = analysis['PEAKS'].split(',')
        print("* using Analysis parameters: ", roi, ' ', analysis_type, ' ', roi_calc, ' ', analysis_filter, ' ',
              peaks_thresh, ',', peaks_lockout, ' ', process)

        # Populate fields with passed values
        self.startSpinBox.setValue(int(start))
        try:
            self.endSpinBox.setValue(int(end))
        except ValueError:
            # Use videos frame count if nothing passed
            self.endSpinBox.setValue(self.currentWindow.frames)

        self.signalTypeComboBox.setCurrentText(str(analysis_type))
        self.roiCalculationComboBox.setCurrentText(roi_calc)
        if pd.isna(analysis_filter):
            self.groupBoxFilter.setChecked(False)
        else:
            self.groupBoxFilter.setChecked(True)
            self.filterFreqSpinBox.setValue(int(analysis_filter))
        self.thresholdDoubleSpinBox.setValue(float(peaks_thresh))
        self.lockoutTimeSpinBox.setValue(int(peaks_lockout))
        # self.allResultsCheckBoxVm.setChecked(process == 'ALL')
        # self.allResultsCheckBoxCa.setChecked(process == 'ALL')

    def checkBoxChangedTimeAll(self):
        """Toggle use of all frames of a video for the current ROI"""
        print('** checkBoxChangedTimeAll')
        if self.checkBoxTimeAll.isChecked():
            self.startSpinBox.setValue(1)
            self.startSpinBox.setEnabled(False)
            self.endSpinBox.setValue(self.currentWindow.frames)
            self.endSpinBox.setEnabled(False)
            print('* UseAll checked')
        else:
            self.startSpinBox.setEnabled(True)
            self.endSpinBox.setEnabled(True)
            print('* UseAll unchecked')

    def filterCheckBoxChanged(self):
        """Toggle use of a low pass filter for the current conditioning"""
        if self.groupBoxFilter.isChecked():
            self.filterFreqSpinBox.setEnabled(True)
            print('\n*** Filter checked')
        else:
            self.filterFreqSpinBox.setEnabled(False)
            print('\n*** Filter unchecked')

    def applyTimeSlice(self):
        """Apply Time Slice tab selections"""
        try:
            print('\n*** Applying Time Slice, Start:', self.startSpinBox.text(),
                  ' End:', self.endSpinBox.text())
            # Set frame range of ROI, or None for all frames
            if not self.checkBoxTimeAll.isChecked():
                self.frame_start = int(self.startSpinBox.text())
                self.frame_end = int(self.endSpinBox.text())
            else:
                self.frame_start = 1
                self.frame_end = self.currentWindow.frames
            self.analysis_preview['FRAMES'] = str(self.frame_start) + '-' + str(self.frame_start)

            print('* Time Slice start/end read')
            roi_data = self.currentWindow.getRoiStack(self.roi_current,
                                                      start_idx=self.frame_start - 1, end_idx=self.frame_end - 1)
            print('* Time Slice roi_data computed')
            # Plot ROI's time-sliced mean values
            roi_data_mean = np.zeros(len(roi_data))
            for idx, frame in enumerate(roi_data):
                roi_data_mean[idx] = np.nanmean(frame)
            roi_data_mean_norm = np.copy(roi_data_mean)
            norm_MIN = roi_data_mean_norm.min()
            norm_MAX = roi_data_mean_norm.max()
            roi_data_mean_norm = (roi_data_mean_norm - norm_MIN) / (norm_MAX - norm_MIN)
            # if 'Voltage' in self.analysis_preview['TYPE']:
            # roi_data_mean_norm = 1 - roi_data_mean_norm
            print('* ROI mean calculated')
            sliced_results = roi_data_mean_norm
            # Plot conditioned signal
            self.plot_preview.plot(sliced_results, clear=True)
            # self.plot_preview.plot(roi_data, clear=True)
            print('* Time Slice roi_data plotted')

            if self.tabProcess.isEnabled():
                self.tabProcess.setEnabled(False)
                self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
            self.tabCondition.setEnabled(True)
            self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabCondition)
            self.progressBar.setValue(10)
        except Exception:
            traceback.print_exc()
        print('\n*** Finished Applying Time Slice')

    def applyCondition(self):
        """Apply Condition tab selections"""
        print('\n*** Applying Condition, Signal Type:', self.signalTypeComboBox.currentText(),
              ' ROI Calc.:', self.roiCalculationComboBox.currentText())
        self.progressBar.setValue(20)
        self.analysis_preview['ROI'] = str(self.comboBoxROIs.currentIndex())
        self.analysis_preview['TYPE'] = self.signalTypeComboBox.currentText()
        self.analysis_preview['ROI_CALC'] = self.roiCalculationComboBox.currentText()
        if self.groupBoxFilter.isChecked():
            self.analysis_preview['FILTER'] = str(self.filterFreqSpinBox.value())
        else:
            self.analysis_preview['FILTER'] = np.nan
        print('** analysis_preview: ', self.analysis_preview)

        # Calculate conditioned ROI data across all frames
        print('** ROI_CALC is ', self.analysis_preview['ROI_CALC'])
        if 'Mean' in self.analysis_preview['ROI_CALC']:
            print('* Calculating ROI mean')
            # Check for/use ROI's frame info
            # if self.analysis_preview['FRAMES']
            roi_data = self.currentWindow.getRoiStack(self.roi_current,
                                                      start_idx=self.frame_start, end_idx=self.frame_end)
            # Allocate space for mean data array
            roi_data_mean = np.zeros(len(roi_data))

            for idx, frame in enumerate(roi_data):
                roi_data_mean[idx] = np.nanmean(frame)
            if 'Voltage' in self.analysis_preview['TYPE']:
                # TODO Signal type should determine Process tab's results options (intensity signal, area, ...)
                roi_data_mean = 1 - roi_data_mean
            print('* ROI mean calculated')

            print('* Filtering ROI data')
            roi_data_mean_filter = roi_data_mean
            if self.groupBoxFilter.isChecked():
                fs = 1 / (self.currentWindow.dt / 1000)
                Wn = (self.filterFreqSpinBox.value() / (fs / 2))
                [b, a] = sig.butter(5, Wn)
                roi_data_mean_filter = sig.filtfilt(b, a, roi_data_mean_filter)
            if self.detrendLinearCheckBox.isChecked():
                roi_data_mean_filter = sig.detrend(roi_data_mean_filter)
            print('* ROI data Filtered')

            print('* Normalizing ROI data')
            roi_data_mean_filter_copy = np.copy(roi_data_mean_filter)
            norm_MIN = roi_data_mean_filter_copy.min()
            norm_MAX = roi_data_mean_filter_copy.max()
            roi_data_mean_filter_norm = (roi_data_mean_filter_copy - norm_MIN) / (norm_MAX - norm_MIN)
            print('* ROI data Normalized')
            self.condition_results = roi_data_mean_filter_norm
        else:
            print('* UNKNOWN ROI_CALC! : ', self.analysis_preview['ROI_CALC'])
        # Plot conditioned signal
        self.plot_preview.plot(self.condition_results, clear=True)

        self.tabPeakDetect.setEnabled(True)
        self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabPeakDetect)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
        self.progressBar.setValue(60)
        print('\n*** Finished Applying Condition')

    def exportTrace(self):
        """Export the trace before Peak Detection"""
        print('\n*** exportTrace!')
        try:
            if self.currentWindow.study:
                file_name_list = [self.currentWindow.study, self.currentWindow.video_name, '']
            else:
                file_name_list = [self.currentWindow.video_name, '']

            file_name_default = '_'.join(file_name_list)

            # File Dialog to generate filename
            export_file_name, _ = QFileDialog.getSaveFileName(self, 'Export results to .csv', file_name_default,
                                                              'Comma-separated values (*.csv)')
            print('* Exporting results as: ', export_file_name)
            pd.DataFrame(self.condition_results).to_csv(export_file_name, na_rep='NaN', index=False)
            print('** Exported results as')
        except Exception:
            traceback.print_exc()

    def applyPeakDetect(self):
        """Apply Peak Detect tab selections"""
        # Detection Error @ trans#  0  our of  7
        # t0_locs[trans]  70 , up_locs[trans]  72 , peak_locs[trans]  75 , base_locs[trans]  14
        # TODO troubleshoot peak detection (is it finding dt and fps?)
        # TODO set y axis to frames, not kframes
        print('\n*** Applying Peak Detect, Threshold:', self.thresholdDoubleSpinBox.value(),
              ' Lockout Time:', self.lockoutTimeSpinBox.value())
        self.progressBar.setValue(60)
        thresh = self.thresholdDoubleSpinBox.value()
        lockout = self.lockoutTimeSpinBox.value()
        param_peaks = str(thresh) + ',' + str(lockout)
        self.analysis_preview['PEAKS'] = param_peaks
        print('** analysis_preview: ', self.analysis_preview)

        print('** PEAKS is ', self.analysis_preview['PEAKS'])
        self.peak_results = peak_detect.peak_detect(f=self.condition_results, thresh=thresh, LOT=lockout)
        [num_peaks, t0_locs, up_locs, peak_locs, base_locs, max_vel, peak_thresh] = self.peak_results
        print('** Detected ', num_peaks, ' peaks above ', peak_thresh)
        print('* max_vel: ', max_vel)

        # Redraw conditioned signal
        self.plot_preview.plot(self.condition_results, clear=True)
        # Mark t0_locs, yellow
        self.plot_preview.plot(t0_locs, self.condition_results[t0_locs], pen=None,
                               symbol='t1', symbolPen=None, symbolSize=10, symbolBrush=(250, 194, 5, 200))
        # Mark up_locs, orange
        self.plot_preview.plot(up_locs, self.condition_results[up_locs], pen=None,
                               symbol='t1', symbolPen=None, symbolSize=10, symbolBrush=(217, 83, 25, 200))
        # Mark peaks, red
        self.plot_preview.plot(peak_locs, self.condition_results[peak_locs], pen=None,
                               symbol='t1', symbolPen=None, symbolSize=10, symbolBrush=(255, 5, 5, 200))
        # Mark base_locs, grey
        self.plot_preview.plot(base_locs, self.condition_results[base_locs], pen=None,
                               symbol='t1', symbolPen=None, symbolSize=10, symbolBrush=(100, 100, 100, 200))
        print('* Peak results (signal, t0_locs, up_locs, peaks, base_locs) plotted')
        # # Mark upstroke
        # for slope in up_locs:
        #     vLine = pg.InfiniteLine(pos=slope, angle=90, movable=False, pen=[100, 255, 100, 80])
        #     self.plot_preview.addItem(vLine)
        #     # Mark the return to baseline
        #     for baseline in base_locs:
        #         if baseline > slope:
        #             vLine = pg.InfiniteLine(pos=baseline, angle=90, movable=False, pen=[100, 255, 100, 80])
        #             self.plot_preview.addItem(vLine)
        #             break
        self.plot_preview.setLabel('left', "Norm. Fluorescence")
        # self.plot_preview.setLabel('bottom', "Time", units='frames')
        # self.plot_preview.getAxis('bottom').enableAutoSIPrefix(enable=False)

        self.tabProcess.setEnabled(True)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
        self.progressBar.setValue(80)
        self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabProcess)
        print('\n*** Finished Applying Peak Detect')

    def applyProcess(self):
        """Apply Process tab selections"""
        print('\n*** Applying Process, All Results')
        self.progressBar.setValue(80)
        [num_peaks, t0_locs, up_locs, peak_locs, base_locs, max_vel, peak_thresh] = self.peak_results
        print('** Processing ', num_peaks, ' peaks above ', peak_thresh)
        print('** analysis_preview: ', self.analysis_preview)
        print('** PROCESS is gone, I am the captain now')

        per_base = 80
        F0 = np.nanmean((self.condition_results[base_locs[1]:t0_locs[0]]))
        # for idx in num_peaks:
        #     F0[idx] = np.nanmean((self.condition_results[base_locs[idx-1]:t0_locs[idx-1]]))
        if 'Voltage' in self.analysis_preview['TYPE']:
            probe = 1
        else:
            probe = 0
        try:
            self.process_results = process.process(self.condition_results, self.currentWindow.dt,
                                                   t0_locs, up_locs, peak_locs, base_locs, max_vel, per_base, F0, probe)
            self.analysis_preview['RESULTS'] = self.process_results
            print('* Process results calculated')

            # TODO FIX rows showing sums of CLs, other values also weird
            table_model = PandasModel(self.process_results)
            self.processTableView.setModel(table_model)
            print('* Results table populated')

            self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(True)
            self.progressBar.setValue(100)
            print('\n*** Finished Applying Process')
        except Exception:
            traceback.print_exc()
            ex_type, ex_value, ex_traceback = sys.exc_info()
            # self.parentWidget().parentWidget().statusBar().showMessage('FAILED to process : ' + str(ex_type))
            print('\n*** Process FAILED')

    def applyAnalysis(self):
        """Add an Analysis to a TIFF or applies changes to an existing Analysis"""
        print('\n*** Applying Analysis')
        if not self.analysis_preview:
            print('** No analysis_preview to add or edit with')
        else:
            if self.comboBoxAnalysis.currentIndex() is 0:
                print('** Applying *NEW* Analysis')
                # self.currentWindow.addAnalysis(self.currentWindow.analysis_default)
                self.currentWindow.addAnalysis(analysis=self.analysis_preview)
            else:
                # Set state of the chosen Analysis (current list index - 1, due to *NEW* at index 0)
                idx_analysis = self.comboBoxAnalysis.currentIndex() - 1
                print('** Changing Analysis #' + str(idx_analysis))
                self.currentWindow.addAnalysis(idx=idx_analysis, analysis=self.analysis_preview)

            if self.tabProcess.isEnabled():
                self.tabProcess.setEnabled(False)
                self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
            if self.tabPeakDetect.isEnabled():
                self.tabPeakDetect.setEnabled(False)
            self.progressBar.setValue(20)
            self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabCondition)
            self.selectionMadeSource(0)
        print('\n*** Apply Analysis done')

    def discardAnalysis(self):
        """Remove an existing Analysis from a TIFF"""
        print('\n*** Discarding Analysis')
        if self.comboBoxAnalysis.currentIndex() is 0:
            print('** Cannot discard *NEW* Analysis!')
        else:
            if len(self.currentAnalysis) < 1:
                print('** No Analysis to discard!')
            else:
                print('** Removing Analysis: ', self.comboBoxAnalysis.currentText())
                idx_analysis = self.comboBoxAnalysis.currentIndex() - 1
                analysis_current = self.currentAnalysis[idx_analysis]

                self.currentWindow.removeAnalysis(idx=idx_analysis, analysis=analysis_current)

                if self.tabProcess.isEnabled():
                    self.tabProcess.setEnabled(False)
                    self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
                if self.tabPeakDetect.isEnabled():
                    self.tabPeakDetect.setEnabled(False)
                self.progressBar.setValue(20)
                self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabCondition)
                self.selectionMadeSource(0)
        print('\n*** Discard Analysis done')


class WindowExport(QWidget, Ui_WidgetExport):
    """Customization for Ui_WidgetExportCopyPaste subwindow for an MDI"""

    def __init__(self, parent=None, w_list=None):
        # initialization of the superclass
        super(WindowExport, self).__init__(parent)
        print('Creating WidgetCopyPaste')
        self.windowList = w_list
        self.currentFileName = ''
        self.currentFilePath = ''
        self.windowDict = {}  # Dictionary with structure "window_name_short": "window"
        name_limit = 50
        for w in self.windowList:
            w_name = w.widget().objectName()
            w_name_short = '..' + w_name[-name_limit:] if len(w_name) > name_limit else w_name
            # Populate dictionary
            self.windowDict[w_name_short] = w.widget()
        self.currentWindow = None
        self.currentAnalysis = None
        self.currentAnalysis_copy = None
        self.currentROI = None
        self.currentResults = None
        self.finalResults = None
        self.clip = QApplication.clipboard()
        # setup the GUI
        print('WidgetCopyPaste UI setup...')
        self.setupUi(self)
        self.comboBoxSource.addItems(self.windowDict.keys())
        self.comboBoxSource.currentIndexChanged['int'].connect(self.selectionMadeSource)
        self.comboBoxAnalysis.currentIndexChanged['int'].connect(self.selectionMadeAnalysis)

        self.radioButtonIndividual.toggled.connect(self.loadResults)
        self.radioButtonIndividual.setChecked(True)
        self.radioButtonMean.toggled.connect(self.loadResults)
        self.checkBoxSD.toggled.connect(self.loadResults)

        self.checkBoxProperties.setChecked(True)
        self.checkBoxProperties.stateChanged.connect(self.loadResults)
        self.checkBoxAPDs.setChecked(True)
        self.checkBoxAPDs.stateChanged.connect(self.loadResults)
        self.checkBoxOther.setChecked(False)
        self.checkBoxOther.stateChanged.connect(self.loadResults)
        self.checkBoxParameters.setChecked(False)
        self.checkBoxParameters.stateChanged.connect(self.loadResults)

        self.pushButtonTrace.clicked.connect(self.copyResults)
        self.pushButtonResults.clicked.connect(self.exportResults)
        self.selectionMadeSource(0)
        print('WidgetCopyPaste ready')

    def selectionMadeSource(self, i):
        """Slot for comboBoxSource.currentIndexChanged"""
        print('** selection made in a ', type(self))
        print('* Current Source: ', i, ', ', self.comboBoxSource.currentText())
        self.currentWindow = self.windowDict[self.comboBoxSource.currentText()]

        self.comboBoxAnalysis.clear()
        for idx, analysis in enumerate(self.currentWindow.Analysis):
            roi, results_type = analysis['ROI'], analysis['TYPE']
            analysis_display = '#' + str(idx) + ': ' + results_type
            self.comboBoxAnalysis.addItem(analysis_display)
            print('Listing Analysis #', idx, ': ', analysis_display)

        print('*Window: ', str(self.currentWindow))
        print('*W x H: ', str(self.currentWindow.width), ' X ',
              str(self.currentWindow.height))

    def selectionMadeAnalysis(self, i):
        """Slot for comboBoxAnalysis.currentIndexChanged"""
        print('\n*** selection #', i, ' made in a ', type(self))
        print('** Current Analysis: ', self.comboBoxAnalysis.currentText())
        index_current = self.comboBoxAnalysis.currentIndex()
        self.currentAnalysis = self.currentWindow.Analysis[index_current]
        self.updateResults(self.currentAnalysis)
        self.radioButtonIndividual.setChecked(True)
        self.loadResults()

    def updateParameters(self):
        """Update Results parameters"""
        print('** Updating Results parameters')
        # try:
        #     if self.checkBoxAPDs.isChecked():
        #
        #     elif self.checkBoxPeriods.isChecked():
        #     else:
        #         if self.radioButtonAllResults.isChecked():
        #             self.checkBoxAPDs.setChecked(False)
        #             self.checkBoxPeriods.setChecked(False)
        #     self.loadResults()
        # except Exception:
        #     traceback.print_exc()

    def updateResults(self, analysis):
        """Update current Analysis and Results"""
        print('\n*** updateResults!')
        self.currentAnalysis_copy = analysis.copy()
        # print('* Old Analysis dict: ', self.currentAnalysis_copy)
        self.currentResults = self.currentAnalysis_copy.pop('RESULTS', None)
        print('** Removed RESULTS : ', self.currentResults)
        print('** New Analysis dict: ', self.currentAnalysis_copy)
        self.currentROI = self.currentAnalysis_copy['ROI']

    def loadResults(self):
        """Populate Results table with the current Analysis' results"""
        print('\n*** loadResults!')
        self.updateResults(self.currentAnalysis)

        # print('** currentResults:' + str(self.currentResults))
        if self.currentResults is None:
            print('\n*** No results yet!')
        else:
            print('** Found results')
            try:
                tempResults = pd.DataFrame()
                tempResultsProps = pd.DataFrame()
                tempResultsAPD = pd.DataFrame()
                tempResultsOther = pd.DataFrame()
                tempResultsParams = pd.DataFrame()

                # Filter based on desired values
                if self.checkBoxAPDs.isChecked():
                    print('* Using APDs')
                    tempResultsAPD = self.currentResults.iloc[:, 4:8]
                if self.checkBoxOther.isChecked():
                    print('* Using all other data')
                    tempResultsOther = self.currentResults.iloc[:, 9:]

                if not self.checkBoxOther.isChecked() and not self.checkBoxAPDs.isChecked():
                    print('* No results columns chosen!')
                tempResults = pd.concat([tempResultsAPD, tempResultsOther], axis=1)

                # Calculate means and SDs, if needed
                if self.radioButtonMean.isChecked():
                    print('* Using Mean results')
                    mean = tempResults.mean(axis=0)
                    mean_SD = pd.Series()
                    mean_combo = pd.Series()
                    self.checkBoxSD.setEnabled(True)
                    if self.checkBoxSD.isChecked():
                        print('* Using SD results')
                        mean_SD = tempResults.std(axis=0)
                        mean_SD_index = [s + '_SD' for s in mean_SD.index]
                        # mean_SD.index = mean_SD_index
                        # Interleave lists of means and SDs
                        mean_combo_list = [np.nan] * (2 * len(mean))
                        mean_combo_index = [np.nan] * (2 * len(mean))
                        mean_combo_list[::2] = mean
                        mean_combo_index[::2] = mean_SD.index
                        mean_combo_list[1::2] = mean_SD
                        mean_combo_index[1::2] = mean_SD_index
                        mean_combo = pd.Series(mean_combo_list)
                        mean_combo.index = mean_combo_index
                        # mean_combo = pd.Series([val for pair in zip(mean, mean_SD) for val in pair])
                    else:
                        mean_combo = mean
                    # tempResults.loc[0] = mean_combo
                    tempResults = mean_combo.to_frame().transpose()
                else:
                    print('* Using Individual results')
                    self.checkBoxSD.setEnabled(False)

                # Check if video Properties are needed
                if self.checkBoxProperties.isChecked():
                    print('* Using Properties')
                    # tempResultsProps = self.currentResults[['']]
                    tempResultsProps = pd.DataFrame(np.zeros(shape=(len(tempResults.index), 3)),
                                                    columns=['Subject', 'File', 'ROI#'])
                    tempResultsProps.loc[:, ['Subject']] = self.currentWindow.study
                    tempResultsProps.loc[:, ['File']] = self.currentWindow.video_name
                    tempResultsProps.loc[:, ['ROI#']] = self.currentAnalysis_copy['ROI']
                tempResults = pd.concat([tempResultsProps, tempResults], axis=1)

                # Check if analysis Paramaters are needed
                # TODO included individual/mean
                if self.checkBoxParameters.isChecked():
                    print('* Using Parameters')
                    tempResultsParams = pd.DataFrame(np.zeros(shape=(len(tempResults.index), 6)),
                                                     columns=['ROI (X,Y)', 'ROI Size',
                                                              'Type', 'Calculation', 'Filter (Hz)',
                                                              'Peaks (Threshold, Lockout)'])

                    params_ROI = self.currentWindow.ROIs[int(self.currentROI)].getState()
                    x, y = str(int(params_ROI['pos'].x())), str(int(params_ROI['pos'].y()))
                    position = x + ',' + y
                    size = int(params_ROI['size'][0])

                    params_Analysis = self.currentAnalysis_copy
                    print('** Parameters:')
                    print('* ROI: ', params_ROI)
                    print('* Analysis: ', params_Analysis)

                    tempResultsParams.loc[:, ['ROI (X,Y)']] = position
                    tempResultsParams.loc[:, ['ROI Size']] = size
                    tempResultsParams.loc[:, ['Type']] = params_Analysis['TYPE']
                    tempResultsParams.loc[:, ['Calculation']] = params_Analysis['ROI_CALC']
                    tempResultsParams.loc[:, ['Filter (Hz)']] = params_Analysis['FILTER']
                    tempResultsParams.loc[:, ['Peaks (Threshold, Lockout)']] = params_Analysis['PEAKS']
                    # tempResultsParams.loc[:, ['ROI']] = 828
                    # tempResultsParams.loc[:, ['Analysis']] = 828
                tempResults = pd.concat([tempResults, tempResultsParams], axis=1)

                # Finalize results table
                self.finalResults = tempResults
                self.tableWidgetResults.setColumnCount(len(self.finalResults.columns))
                self.tableWidgetResults.setRowCount(len(self.finalResults.index))

                for i in range(len(self.finalResults.index)):
                    for j in range(len(self.finalResults.columns)):
                        dataDataFrame = self.finalResults.iat[i, j]
                        try:
                            # Round all float results to 5 significant digits, due to dt limit
                            float(dataDataFrame)
                            dataTable = str("{0:.5g}".format(dataDataFrame))
                        except ValueError:
                            # Not a float, no need to limit digits
                            dataTable = dataDataFrame
                        self.tableWidgetResults.setItem(i, j, QTableWidgetItem(dataTable))
                print('* Results table populated by results dataframe')
                self.tableWidgetResults.setHorizontalHeaderLabels(self.finalResults.columns)
                self.tableWidgetResults.resizeRowsToContents()
                self.tableWidgetResults.resizeColumnsToContents()
            except Exception:
                traceback.print_exc()

            print('** Results loaded!')

    def copyResults(self):
        print('\n*** copyResults!')
        try:
            print('** copy...')
            selected = self.tableWidgetResults.selectedRanges()
            # s = '\t' + "\t".join([str(self.tableWidgetResults.horizontalHeaderItem(i).text()) for i in
            #                       range(selected[0].leftColumn(), selected[0].rightColumn())])
            s = "\t".join([str(self.tableWidgetResults.horizontalHeaderItem(i).text()) for i in
                           range(selected[0].leftColumn(), selected[0].rightColumn())])
            s = s + '\n'
            for r in range(selected[0].topRow(), selected[0].bottomRow()):
                # s += self.tableWidgetResults.verticalHeaderItem(r).text() + '\t'
                # s += str(self.tableWidgetResults.verticalHeaderItem(r).text()) + '\t'
                for c in range(selected[0].leftColumn(), selected[0].rightColumn()):
                    try:
                        print('** try: s += str(self.table.item(r, c).text()) + "\t"')
                        s += str(self.tableWidgetResults.item(r, c).text()) + "\t"
                    except AttributeError:
                        s += "\t"
                s = s[:-1] + "\n"  # eliminate last '\t'
            self.clip.setText(s)
        except Exception:
            traceback.print_exc()

    def exportTrace(self):
        """Export the trace from the current Analysis"""
        print('\n*** exportTrace!')
        self.updateResults(self.currentAnalysis)

        if self.currentResults is None:
            print('\n*** No results yet!')
        else:
            print('** Found results')
            try:
                tempResults = pd.DataFrame()
            except Exception:
                traceback.print_exc()

    def exportResults(self):
        """Export the results from the current Analysis"""
        print('\n*** exportResults!')
        try:
            if self.currentWindow.study:
                file_name_list = [self.currentWindow.study, self.currentWindow.video_name, '']
            else:
                file_name_list = [self.currentWindow.video_name, '']

            file_name_default = '_'.join(file_name_list)

            # File Dialog to generate filename
            export_file_name, _ = QFileDialog.getSaveFileName(self, 'Export results to .csv', file_name_default,
                                                              'Comma-separated values (*.csv)')
            print('* Exporting results as: ', export_file_name)
            self.finalResults.to_csv(export_file_name, na_rep='NaN', index=False)
            print('** Exported results as')
        except Exception:
            traceback.print_exc()
        # selected = self.tableWidgetResults.selectedRanges()
        # # s = '\t' + "\t".join([str(self.tableWidgetResults.horizontalHeaderItem(i).text()) for i in
        # #                       range(selected[0].leftColumn(), selected[0].rightColumn())])
        # s = "\t".join([str(self.tableWidgetResults.horizontalHeaderItem(i).text()) for i in
        #                range(selected[0].leftColumn(), selected[0].rightColumn())])
        # s = s + '\n'
        # for r in range(selected[0].topRow(), selected[0].bottomRow()):
        #     # s += self.tableWidgetResults.verticalHeaderItem(r).text() + '\t'
        #     # s += str(self.tableWidgetResults.verticalHeaderItem(r).text()) + '\t'
        #     for c in range(selected[0].leftColumn(), selected[0].rightColumn()):
        #         try:
        #             print('** try: s += str(self.table.item(r, c).text()) + "\t"')
        #             s += str(self.tableWidgetResults.item(r, c).text()) + "\t"
        #         except AttributeError:
        #             s += "\t"
        #     s = s[:-1] + "\n"  # eliminate last '\t'
        # self.clip.setText(s)


class PandasModel(QtCore.QAbstractTableModel):
    """
    Class to populate a table view with a pandas dataframe
    """

    def __init__(self, data, parent=None):
        QtCore.QAbstractTableModel.__init__(self, parent)
        self._data = data

    def rowCount(self, parent=None, **kwargs):
        return self._data.shape[0]

    def columnCount(self, parent=None, **kwargs):
        return self._data.shape[1]

    def data(self, index, role=QtCore.Qt.DisplayRole):
        if index.isValid():
            if role == QtCore.Qt.DisplayRole:
                return str(self._data.iloc[index.row(), index.column()])
        return None

    def headerData(self, col, orientation, role=None):
        if orientation == QtCore.Qt.Horizontal and role == QtCore.Qt.DisplayRole:
            return self._data.columns[col]
        return None


if __name__ == '__main__':
    # create the GUI application
    app = QApplication(sys.argv)
    # instantiate the main window
    dmw = MDIWindow()
    # show it
    dmw.show()
    # start the Qt main loop execution, exiting from this script
    # with the same return code as the Qt application
    sys.exit(app.exec_())
