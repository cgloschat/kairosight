#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import sys
import traceback
import numpy as np
import pandas as pd
from pathlib import PurePath

import scipy.signal as sig
from PyQt5 import QtCore
from PyQt5.QtCore import QDir, Qt
from PyQt5.QtGui import QStandardItemModel
from PyQt5.QtWidgets import QApplication, QWidget, QMainWindow, QFileDialog, QFileSystemModel, QDialogButtonBox
import pyqtgraph as pg
from ui.KairoSightMainMDI import Ui_MDIMainWindow
from ui.KairoSightWidgetTIFFpyqtgraph import Ui_WidgetTiff
from ui.KairoSightWidgetFolderTree import Ui_WidgetFolderTree
from ui.KairoSightWidgetImagePrep import Ui_WidgetImagePrep
from ui.KairoSightWidgetIsolate import Ui_WidgetIsolate
from ui.KairoSightWidgetAnalyze import Ui_WidgetAnalyze
from algorithms import tifopen, peak_detect, process


# TODO review/remove/reformat print statements
# TODO change MainWindow's subwindow creation methods to "Window..."

class DesignerMainWindow(QMainWindow, Ui_MDIMainWindow):
    """Customization for Ui_MDIMainWindow, and MDI main window"""
    def __init__(self, parent=None):
        # initialization of the superclass
        super(DesignerMainWindow, self).__init__(parent)
        # setup the GUI --> function generated by pyuic4
        self.setupUi(self)
        # connect the signals with the slots
        # self.actionLoad.triggered.connect(self.open_tiff)
        # self.actionClose.triggered.connect(self.close)
        self.actionTIFF.triggered.connect(self.open_tiff)
        self.actionFolder.triggered.connect(self.open_folder)
        self.actionStart_ImagePrep.triggered.connect(self.image_prep)
        self.actionStart_Isolate.triggered.connect(self.isolate)
        self.actionStart_Analyze.triggered.connect(self.analyze)

    def open_tiff(self, file=None):
        """Open a SubWindow with a TIFF stack in the main MDI area"""
        if file:
            print('Opening tiff with passed filepath: ' + file)
        else:
            # Use a QFileDialog to get filepath if none provided
            file, mask = QFileDialog.getOpenFileName(self, 'Open a .tif/.tiff stack')

        if file:
            self.statusBar().showMessage('Opening ' + file + ' ...')
            f_purepath = PurePath(file)
            f_path = str(f_purepath.parent) + '\\'
            f_name = f_purepath.stem
            f_ext = f_purepath.suffix
            f_display = f_path + ' ' + f_name + ' ' + f_ext
            print('file (path name ext): ' + f_display)
            if f_ext is '.tif' or '.tiff':
                # print('TIFF chosen')
                # Create QMdiSubWindow with Ui_WidgetTiff
                try:
                    sub = DesignerSubWindowTiff(f_path=f_path, f_name=f_name, f_ext=f_ext)
                    # print('DesignerSubWindowTiff "sub" created')
                    sub.setObjectName(str(file))
                    sub.setWindowTitle('TIFF View: ' + f_display)
                    # Add and connect QMdiSubWindow to MDI
                    self.mdiArea.addSubWindow(sub)
                    # print('"sub" added to MDI')
                    sub.show()
                    self.statusBar().showMessage('Opened ' + file)
                except Exception:
                    traceback.print_exc()
                    ex_type, ex_value, ex_traceback = sys.exc_info()
                    self.statusBar().showMessage('Failed to open, ' + file + ' : ' + str(ex_type))
        else:
            print('path is None')
            self.statusBar().showMessage('Open cancelled')

    def open_folder(self):
        """Open a SubWindow with a folder tree view in the main MDI area"""
        folder_path = QFileDialog.getExistingDirectory(self, 'Choose a folder to view')
        print('Folder chosen! path: ' + folder_path)
        # Create QMdiSubWindow with Ui_WidgetTiff
        sub = DesignerSubWindowFolder(root=folder_path)
        print('DesignerSubWindowFolder "sub" created')
        print('Set "sub" widget to "Ui_WidgetFolderTree"')
        sub.setWindowTitle('Folder View: ' + folder_path)
        # Add and connect QMdiSubWindow to MDI
        self.mdiArea.addSubWindow(sub)
        sub.pushButtonOpen.released.connect(lambda: self.open_tiff(sub.currentFilePath))
        print('"sub" added to MDI')
        sub.show()

    def image_prep(self):
        """Open the Image Process SubWindow"""
        tiff_windows = []
        # Create a list of all open TIFF subwindows
        for sub in self.mdiArea.subWindowList():
            # print('**' + str(type(sub.widget())) + ', ' + sub.widget().objectName() + ' is a tiff? ')
            if type(sub.widget()) is DesignerSubWindowTiff:
                tiff_windows.append(sub)
        if tiff_windows:
            sub_process = DesignerSubWindowImagePrep(w_list=tiff_windows)
            self.mdiArea.addSubWindow(sub_process)
            sub_process.show()
        else:
            self.statusBar().showMessage('No open videos to process!')

    def isolate(self):
        """Open the Isolate SubWindow"""
        tiff_windows = []
        # Create a list of all open TIFF subwindows
        for sub in self.mdiArea.subWindowList():
            # print('**' + str(type(sub.widget())) + ', ' + sub.widget().objectName() + ' is a tiff? ')
            if type(sub.widget()) is DesignerSubWindowTiff:
                if sub.widget().Preps:
                    tiff_windows.append(sub)
        if tiff_windows:
            sub_iso = DesignerSubWindowIsolate(w_list=tiff_windows)
            self.mdiArea.addSubWindow(sub_iso)
            sub_iso.show()
        else:
            self.statusBar().showMessage('No processed videos to isolate!')

    def analyze(self):
        """Open the Analyze SubWindow"""
        tiff_windows = []
        # Create a list of all open TIFF subwindows
        for sub in self.mdiArea.subWindowList():
            # print('**' + str(type(sub.widget())) + ', ' + sub.widget().objectName() + ' is a tiff? ')
            if type(sub.widget()) is DesignerSubWindowTiff:
                if sub.widget().ROIs:
                    tiff_windows.append(sub)
        if tiff_windows:
            sub_analyze = DesignerSubWindowAnalyze(w_list=tiff_windows)
            self.mdiArea.addSubWindow(sub_analyze)
            sub_analyze.show()
        else:
            self.statusBar().showMessage('No processed videos with ROIs to analyze!')


class DesignerSubWindowTiff(QWidget, Ui_WidgetTiff):
    """Customization for Ui_WidgetTiff subwindow for an MDI"""
    # TODO remove Preps from UI
    # TODO add Export to csv (study, file, roi, ...)
    # TODO build a better data tree for Preps, ROIs, and Analysis
    INDEX_P, TRANSFORM, BACKGROUND = range(3)
    INDEX_R, PREP, TYPE, POSITION, SIZE, FRAMES = range(6)
    INDEX_A, ROI, TYPE, ROI_CALC, FILTER, PEAKS = range(6)

    def __init__(self, parent=None, f_path=None, f_name=None, f_ext=None):
        # Initialization of the superclass
        super(DesignerSubWindowTiff, self).__init__(parent)
        # Setup the GUI
        self.setupUi(self)
        pg.setConfigOptions(background=pg.mkColor(0.1))
        pg.setConfigOptions(foreground=pg.mkColor(0.3))
        # Preserve plot area's aspect ration so image always scales correctly
        self.graphicsView.p1.setAspectLocked(True)
        # Connect the scrollbar's value signal to trigger a video update
        self.horizontalScrollBar.valueChanged['int'].connect(self.updateVideo)
        # Load the video file
        self.video_path = f_path
        self.video_name = f_name
        self.video_ext = f_ext
        self.video_file, self.dt = tifopen.tifopen(self.video_path, self.video_name + self.video_ext)
        # print('tifopen finished')
        # get video properties
        self.video_shape = self.video_file.shape
        if len(self.video_shape) < 3:
            raise Exception('TIFF has less than 3 dimensions')
        self.frames = self.video_shape[0]

        # Transpose second and third axes (y, x) to correct orientation (x, y)
        self.video_data = np.transpose(self.video_file, (0, 2, 1))
        # Flip each frame in the left/right direction, expected to be up/down
        for i in range(self.frames):
            self.video_data[i] = np.fliplr(self.video_data[i])

        # Use a dummy dt (aka Frame Period) if none detected
        # From MetaMorph: for exposure time 1.219 ms, dt = 1.238 ms
        if np.isnan(self.dt):
            self.dt = 1.238

        self.fps = 1000 / self.dt
        self.duration = self.fps * (self.frames + 1)
        self.width, self.height = self.video_shape[2], self.video_shape[1]
        print('video shape:         ', self.video_shape)
        print('Width x Height:      ', self.width, self.height)
        print('# of Frames:         ', self.frames)
        print('Frame Period (ms):   ', self.dt)
        print('FPS:                 ', self.fps)
        print('Duration (ms):       ', self.duration)
        self.SizeLabelEdit.setText(str(self.width) + ' X ' + str(self.height) + ' (X ' + str(self.frames) + ')')

        self.framePeriodMsLineEdit.setText(str(self.dt))
        self.framePeriodMsLineEdit.setEnabled(False)
        self.frameRateLineEdit.setText(str(self.fps))
        self.frameRateLineEdit.setEnabled(False)
        self.durationMsLineEdit.setText(str(self.duration))
        self.durationMsLineEdit.setEnabled(False)

        # Setup Preps, ROIs, and Anlysis variables
        self.Preps = []  # A list of prep dictionaries
        self.prep_default = {'transform': '0', 'background': '0,0'}
        self.ROIs = []  # A list of pg.ROI objects
        self.Analysis = []  # A list of Analysis results dictionaries
        self.analysis_default = {'ROI': '0', 'INDEX_A': np.nan, 'TYPE': 'Voltage',
                                 'ROI_CALC': 'Mean', 'FILTER': '60', 'PEAKS': '0.72,172'}
        # Set scroll bar maximum to number of frames
        self.horizontalScrollBar.setMinimum(1)
        self.horizontalScrollBar.setMaximum(self.frames)
        self.frame_current = 0
        # Set histogram to image levels and use a manual range
        self.graphicsView.hist.setLevels(self.video_data.min(), self.video_data.max())
        self.graphicsView.hist.setHistogramRange(self.video_data.min(), self.video_data.max())

        # Setup data treeviews
        # Calling it a treeview, currently connected to table-like models
        self.treeViewPreps.setAlternatingRowColors(True)
        self.treeViewROIs.setAlternatingRowColors(True)
        self.treeViewAnalysis.setAlternatingRowColors(True)
        # Preps model
        self.modelPrep = QStandardItemModel(0, 3)
        self.modelPrep.setHeaderData(self.INDEX_P, Qt.Horizontal, "#")
        self.modelPrep.setHeaderData(self.TRANSFORM, Qt.Horizontal, "Transform")
        self.modelPrep.setHeaderData(self.BACKGROUND, Qt.Horizontal, "Background")
        self.treeViewPreps.setModel(self.modelPrep)
        # ROI model
        self.modelRoi = QStandardItemModel(0, 6)
        self.modelRoi.setHeaderData(self.INDEX_R, Qt.Horizontal, "#")
        self.modelRoi.setHeaderData(self.PREP, Qt.Horizontal, "Prep#")
        self.modelRoi.setHeaderData(self.TYPE, Qt.Horizontal, "Type")
        self.modelRoi.setHeaderData(self.POSITION, Qt.Horizontal, "Position (X,Y)")
        self.modelRoi.setHeaderData(self.SIZE, Qt.Horizontal, "Size (px)")
        self.modelRoi.setHeaderData(self.FRAMES, Qt.Horizontal, "Frames")
        self.treeViewROIs.setModel(self.modelRoi)
        # Analysis model
        self.modelAnalysis = QStandardItemModel(0, 6)
        self.modelAnalysis.setHeaderData(self.INDEX_A, Qt.Horizontal, "#")
        self.modelAnalysis.setHeaderData(self.ROI, Qt.Horizontal, "ROI#")
        self.modelAnalysis.setHeaderData(self.TYPE, Qt.Horizontal, "Type")
        self.modelAnalysis.setHeaderData(self.ROI_CALC, Qt.Horizontal, "ROI Calc.")
        self.modelAnalysis.setHeaderData(self.FILTER, Qt.Horizontal, "Filter")
        self.modelAnalysis.setHeaderData(self.PEAKS, Qt.Horizontal, "Peak Det.")
        self.treeViewAnalysis.setModel(self.modelAnalysis)
        # TODO use double-click to view analysis results

        # Add default prep, with no transform or background removal
        self.addPrep(prep=self.prep_default)
        print('WidgetTiff ready')

    def updateVideo(self, frame=0):
        """Updates the video frame drawn to the canvas"""
        # print('Updating video plot in a subWindow with:')
        print('*** Showing ' + self.video_name + '[' + str(frame) + ']')
        # Update ImageItem with a frame in stack
        self.frame_current = frame
        self.graphicsView.img.setImage(self.video_data[frame - 1])
        # Notify histogram item of image change
        self.graphicsView.hist.regionChanged()
        try:
            if self.ROIs:
                # Draw ROIs
                for roi in self.ROIs:
                    self.graphicsView.p1.addItem(roi)
        except Exception:
            traceback.print_exc()

    def getRoiPreview(self, roi):
        data = self.video_data[self.frame_current]
        data_img = self.graphicsView.img
        data_preview = roi.getArrayRegion(data, data_img)
        return data_preview

    def getRoiStack(self, roi):
        data_stack = []
        for idx, frame in enumerate(self.video_data):
            data_img = self.graphicsView.img
            data_roi_frame = roi.getArrayRegion(frame, data_img)
            data_roi_frame[data_roi_frame == 0] = np.nan
            data_stack.append(data_roi_frame)
        return data_stack

    def addPrep(self, idx=None, prep=None):
        if prep:
            print('* Preps were: ', self.Preps)
            transform = prep['transform']
            background = prep['background']
            if idx:
                prep_current = self.Preps[idx]
                print('** Changing existing Analysis from: ', prep_current)
                print('**                              to: ', prep)
                self.Preps[idx] = prep.copy()
            else:
                print('** Adding passed prep: ', prep)
                self.Preps.append(prep.copy())
                length = self.modelPrep.rowCount()
                idx = length
                self.modelPrep.insertRow(length)
            self.modelPrep.setData(self.modelPrep.index(idx, self.INDEX_P), idx)
            self.modelPrep.setData(self.modelPrep.index(idx, self.TRANSFORM), transform)
            self.modelPrep.setData(self.modelPrep.index(idx, self.BACKGROUND), background)
            print('* Preps are now: ', self.Preps)
        else:
            print('** No Prep to add!')

    def removePrep(self, idx=None, prep=None):
        if prep:
            print('** Removing passed prep: ', prep)
            preps_new = [j for i, j in enumerate(self.Preps) if i not in [idx]]
            self.Preps = preps_new
            self.modelPrep.removeRow(idx)
        else:
            print('** No Prep to remove!')

    def addROI(self, idx_prep=0, idx=None, roi=None, frames=None):
        print('*** addROI: idx:', idx, ' roi:', roi, ' frames:', frames)
        if roi:
            print('* ROIs were: ', self.ROIs)
            roi.translatable = False
            roi_state = roi.getState()
            x, y = str(int(roi_state['pos'].x())), str(int(roi_state['pos'].y()))
            position = x + ',' + y
            r = int(roi_state['size'][0])

            if idx is not None:
                roi_current = self.ROIs[idx]
                print('** Changing existing Analysis from: ', roi_current)
                print('**                              to: ', roi)
                roi_current.setState(roi_state)
                roi_current.setPen(color='54FF00')
            else:
                print('** Adding passed ROI: ', roi)
                length = self.modelRoi.rowCount()
                idx = length
                self.modelRoi.insertRow(idx)
                roi_new = pg.CircleROI([x, y], [r, r], pen=(2, 9), movable=False)
                roi_new.setPen(color='54FF00')
                self.graphicsView.p1.addItem(roi_new)
                self.ROIs.append(roi_new)
                roi_new.removeHandle(0)
            if not frames:
                frames = '1-' + str(self.frames)

            self.modelRoi.setData(self.modelRoi.index(idx, self.INDEX_R), idx)
            self.modelRoi.setData(self.modelRoi.index(idx, self.PREP), idx_prep)
            self.modelRoi.setData(self.modelRoi.index(idx, self.TYPE), 'Circle')
            self.modelRoi.setData(self.modelRoi.index(idx, self.POSITION), position)
            self.modelRoi.setData(self.modelRoi.index(idx, self.SIZE), r)
            self.modelRoi.setData(self.modelRoi.index(idx, self.FRAMES), frames)
            # print('* ROIs are now: ', self.ROIs)
        else:
            print('** No ROI to add!')

    def removeROI(self, idx=None, roi=None):
        if roi:
            print('** Removing passed ROI: ', roi)
            rois_new = [j for i, j in enumerate(self.ROIs) if i not in [idx]]
            self.ROIs = rois_new
            self.modelRoi.removeRow(idx)
            self.graphicsView.p1.removeItem(roi)
        else:
            print('** No ROI to remove!')

    def addAnalysis(self, idx=None, analysis=None):
        if analysis:
            print('*** addAnalysis: idx:', idx, ' analysis:', analysis)
            roi = analysis['ROI']
            type = analysis['TYPE']
            roi_calc = analysis['ROI_CALC']
            filter = analysis['FILTER']
            peaks = analysis['PEAKS']
            if idx is not None:
                analysis_current = self.Analysis[idx]
                print('** Changing existing Analysis from: ', analysis_current)
                print('**                              to: ', analysis)
                self.Analysis[idx] = analysis.copy()
            else:
                print('** Adding passed Analysis: ', analysis)
                self.Analysis.append(analysis.copy())
                length = self.modelAnalysis.rowCount()
                idx = length
                self.modelAnalysis.insertRow(idx)

            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.INDEX_A), str(idx))
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.ROI), roi)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.TYPE), type)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.ROI_CALC), roi_calc)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.FILTER), filter)
            self.modelAnalysis.setData(self.modelAnalysis.index(idx, self.PEAKS), peaks)
        else:
            print('** No Analysis to add!')

    def removeAnalysis(self, idx=None, analysis=None):
        if analysis:
            print('** Removing passed Analysis: ', analysis)
            analysis_new = [j for i, j in enumerate(self.Analysis) if i not in [idx]]
            self.Analysis = analysis_new
            self.modelAnalysis.removeRow(idx)
        else:
            print('** No Analysis to remove!')


class DesignerSubWindowFolder(QWidget, Ui_WidgetFolderTree):
    """Customization for Ui_WidgetFolderTree subwindow for an MDI"""

    def __init__(self, parent=None, root=None):
        # initialization of the superclass
        super(DesignerSubWindowFolder, self).__init__(parent)
        self.dir = QDir(root)
        self.currentFileName = ''
        self.currentFilePath = ''
        # setup the GUI
        self.setupUi(self)
        print('WidgetFolderTree UI setup')
        self.model = QFileSystemModel()
        self.model.setRootPath(root)
        self.treeView.setModel(self.model)
        self.treeView.setRootIndex(self.model.index(root))
        print('treeView ready')

    @QtCore.pyqtSlot(QtCore.QModelIndex)
    def on_treeView_clicked(self, index):
        index_item = self.model.index(index.row(), 0, index.parent())
        self.currentFileName = self.model.fileName(index_item)
        self.currentFilePath = self.model.filePath(index_item)
        print('Clicked: ' + self.currentFilePath + ' ' + self.currentFileName)


class DesignerSubWindowImagePrep(QWidget, Ui_WidgetImagePrep):
    """Customization for Ui_WidgetImagePrep subwindow for an MDI"""

    # TODO move *NEW* combobox items to the ends, rather than the beginnings

    def __init__(self, parent=None, w_list=None):
        # initialization of the superclass
        super(DesignerSubWindowImagePrep, self).__init__(parent)
        print('Creating WidgetImagePrep')
        self.windowList = w_list
        self.currentFileName = ''
        self.currentFilePath = ''
        self.windowDict = {}  # Dictionary with structure "window_name_short": "window"
        name_limit = 50
        for w in self.windowList:
            w_name = w.widget().objectName()
            w_name_short = '..' + w_name[-name_limit:] if len(w_name) > name_limit else w_name
            # Populate dictionary
            self.windowDict[w_name_short] = w.widget()
        self.currentWindow = None
        self.currentPlot = None
        self.currentPreps = []
        self.prep_preview = {'transform': 'NeW', 'background': 'NeW'}
        # setup the GUI
        print('WidgetImagePrep UI setup...')
        self.setupUi(self)
        self.comboBoxSource.addItems(self.windowDict.keys())
        self.comboBoxSource.currentIndexChanged['int'].connect(self.selectionMadeSource)
        self.comboBoxPreps.currentIndexChanged['int'].connect(self.selectionMadePrep)

        self.checkBoxApplyTransform.stateChanged.connect(self.checkBoxChangedTransform)
        self.rotateComboBox.currentIndexChanged['int'].connect(self.checkBoxChangedTransform)
        self.rotateComboBox.setEnabled(False)
        self.checkBoxApplyRemoveBackground.stateChanged.connect(self.checkBoxChangedRemoveBackground)
        self.thresholdSpinBox.valueChanged.connect(self.checkBoxChangedRemoveBackground)
        self.thresholdSpinBox.setEnabled(False)
        self.minSizeSpinBox.valueChanged.connect(self.checkBoxChangedRemoveBackground)
        self.minSizeSpinBox.setEnabled(False)

        self.buttonBox.button(QDialogButtonBox.Apply).clicked.connect(self.applyPrep)
        self.buttonBox.button(QDialogButtonBox.Discard).clicked.connect(self.discardPrep)
        # self.checkBoxPreview.stateChanged.connect(self.checkBoxChangedPreview)
        self.selectionMadeSource(0)
        # self.listWidgetOpenTiffs.addItems(self.windowListNames)
        print('WidgetImagePrep ready')

    def selectionMadeSource(self, i):
        """Slot for comboBoxSource.currentIndexChanged"""
        print('** selection made in a ', type(self))
        print('* Current source: ', i, ', ', self.comboBoxSource.currentText())
        self.currentWindow = self.windowDict[self.comboBoxSource.currentText()]
        self.currentPlot = self.currentWindow.graphicsView.p1
        self.currentPreps = self.currentWindow.Preps

        self.comboBoxPreps.clear()
        self.comboBoxPreps.addItem('*New*')
        for idx, prep in enumerate(self.currentPreps):
            self.comboBoxPreps.addItem('#' + str(idx) + ': ' + str(prep))
            print('Listing Prep #', idx, ': ', prep)

        print('*Window: ', str(self.currentWindow))
        print('*W x H: ', str(self.currentWindow.width), ' X ', str(self.currentWindow.height))
        print('*Preps: ', str(self.currentPreps))
        self.loadDefaults()

    def selectionMadePrep(self, i):
        """Slot for comboBoxPreps.currentIndexChanged"""
        print('** selection made in a ', type(self))
        print('* Current Prep: #', i, ': ', self.comboBoxPreps.currentText())
        index_current = self.comboBoxPreps.currentIndex()
        if index_current > 0:
            # An existing Prep has been selected
            prep_current = self.currentWindow.Preps[index_current - 1]
            print('* Prep #', index_current - 1, ': ', str(prep_current))
            self.updateParameters(prep_current)
        else:
            # *NEW* has been selected
            self.loadDefaults()

    def loadDefaults(self):
        """Populate Prep parameter inputs with default values"""
        self.checkBoxApplyTransform.setChecked(False)
        self.checkBoxApplyRemoveBackground.setChecked(False)
        self.prep_preview = self.currentWindow.prep_default

    def updateParameters(self, prep):
        """Populate Prep parameter inputs with an existing Prep's parameters"""
        rotate = prep['transform']
        background_thresh, background_min = prep['background'].split(',')
        print("Updating prep params with: ", rotate, ' ', background_thresh, ',', background_min)
        # Populate fields with passed values
        if int(rotate) is 0:
            self.checkBoxApplyTransform.setChecked(False)
        else:
            self.checkBoxApplyTransform.setChecked(True)
            self.rotateComboBox.setCurrentIndex(self.rotateComboBox.findText(rotate))
        if int(background_thresh) is 0 and int(background_min) is 0:
            self.checkBoxApplyRemoveBackground.setChecked(False)
        else:
            self.checkBoxApplyRemoveBackground.setChecked(True)
            self.thresholdSpinBox.setValue(int(background_thresh))
            self.minSizeSpinBox.setValue(int(background_min))

    def checkBoxChangedTransform(self):
        """Enable/disable and read Transform parameter entry"""
        if self.checkBoxApplyTransform.isChecked():
            if not self.rotateComboBox.isEnabled():
                # Enable
                self.rotateComboBox.setEnabled(True)
            # Get parameter
            transform = self.rotateComboBox.currentText()
            self.prep_preview['transform'] = transform
        else:
            # Disable
            self.prep_preview['transform'] = '0'
            self.rotateComboBox.setEnabled(False)

    def checkBoxChangedRemoveBackground(self):
        """Enable/disable and read Remove Background parameter entry"""
        if self.checkBoxApplyRemoveBackground.isChecked():
            if not self.thresholdSpinBox.isEnabled():
                # Enable
                self.thresholdSpinBox.setEnabled(True)
                self.minSizeSpinBox.setEnabled(True)
            # Get parameters
            thresh, min_size = str(self.thresholdSpinBox.value()), str(self.minSizeSpinBox.value())
            background = thresh + ',' + min_size
            self.prep_preview['background'] = background
        else:
            # Disable
            self.prep_preview['background'] = '0,0'
            self.thresholdSpinBox.setEnabled(False)
            self.minSizeSpinBox.setEnabled(False)

    def updatePreview(self):
        """Update Prep preview parameter"""
        # if self.roi_preview:
        #     # Get current video frame data and preview ROI data
        #     data_frame = self.currentWindow.video_data[self.currentWindow.frame_current]
        #     data_preview = self.currentWindow.getRoiPreview(self.roi_preview)
        #
        #     # self.roi_preview.setParentItem(img_preview)
        #     # Draw preview data in isolate subwindow
        #     self.img_preview.setImage(data_preview, levels=(0, data_frame.max()))
        #     self.v_preview.autoRange()
        # else:
        #     print('No ROI preview to update!')

    def applyPrep(self):
        """Add a Prep to a TIFF or applies changes to an existing Prep"""
        if self.comboBoxPreps.currentIndex() is 0:
            if not self.prep_preview:
                print('No Prep to add')
                return
            # Add the preview Prep to the current TIFF window
            print('*** Applying *NEW* Prep')
            self.currentWindow.addPrep(prep=self.prep_preview)
        elif self.comboBoxPreps.currentIndex() is 1:
            print('Cannot change default Prep')
            return
        else:
            # Set state of the chosen Prep (current list index - 1, due to *NEW* at index 0)
            idx_prep = self.comboBoxPreps.currentIndex() - 1
            print('*** Changing Prep ' + str(idx_prep))
            self.currentWindow.addPrep(idx=idx_prep, prep=self.prep_preview)
        self.prep_preview = {'transform': 'NeW', 'background': 'NeW'}
        self.selectionMadeSource(0)
        self.checkBoxChangedTransform()
        self.checkBoxChangedRemoveBackground()
        self.loadDefaults()

    def discardPrep(self):
        """Remove an existing Prep from a TIFF"""
        if len(self.currentPreps) < 2:
            print('Cannot discard default prep!')
        else:
            self.currentWindow.removePrep(idx=self.comboBoxPreps.currentIndex() - 1, prep=self.prep_preview)
        self.prep_preview = {'transform': 'NeW', 'background': 'NeW'}
        self.selectionMadeSource(0)
        self.checkBoxChangedTransform()
        self.checkBoxChangedRemoveBackground()
        self.loadDefaults()


class DesignerSubWindowIsolate(QWidget, Ui_WidgetIsolate):
    """Customization for Ui_WidgetIsolate subwindow for an MDI"""

    # TODO Populate currentROIs based on selected Prep
    # TODO move *NEW* combobox items to the ends, rather than the beginnings
    # TODO change to "Isolate ROIs"

    def __init__(self, parent=None, w_list=None):
        # initialization of the superclass
        super(DesignerSubWindowIsolate, self).__init__(parent)
        print('Creating WidgetIsolate')
        self.windowList = w_list
        self.currentFileName = ''
        self.currentFilePath = ''
        self.windowDict = {}  # Dictionary with structure "window_name_short": "window"
        name_limit = 50
        for w in self.windowList:
            w_name = w.widget().objectName()
            w_name_short = '..' + w_name[-name_limit:] if len(w_name) > name_limit else w_name
            # Populate dictionary
            self.windowDict[w_name_short] = w.widget()
        self.currentWindow = None
        self.currentPlot = None
        self.currentPreps = []
        self.currentROIs = []
        self.roi_preview = None
        # setup the GUI
        print('WidgetIsolate UI setup...')
        self.setupUi(self)
        # Setup preview plot in isolate subwindow
        # TODO remove border around preview, maybe switch to:
        #         self.rawImg = RawImageWidget(QWidget())
        w_preview = self.widgetPreview.addLayout(row=0, col=0)
        self.v_preview = w_preview.addViewBox(lockAspect=True)
        self.img_preview = pg.ImageItem()
        self.v_preview.addItem(self.img_preview)
        self.v_preview.disableAutoRange('xy')
        self.v_preview.autoRange()

        self.comboBoxSource.addItems(self.windowDict.keys())
        self.comboBoxSource.currentIndexChanged['int'].connect(self.selectionMadeSource)
        self.comboBoxPreps.currentIndexChanged['int'].connect(self.selectionMadePrep)
        self.comboBoxROIs.currentIndexChanged['int'].connect(self.selectionMadeROI)

        self.originXLineEdit.textEdited.connect(self.checkBoxChangedPreview)
        self.originYLineEdit.textEdited.connect(self.checkBoxChangedPreview)
        self.radiusSpinBox.valueChanged.connect(self.checkBoxChangedPreview)

        self.checkBoxTimeAll.stateChanged.connect(self.checkBoxChangedTimeAll)

        self.buttonBox.button(QDialogButtonBox.RestoreDefaults).clicked.connect(self.loadDefaults)
        self.buttonBox.button(QDialogButtonBox.Apply).clicked.connect(self.applyROI)
        self.buttonBox.button(QDialogButtonBox.Discard).clicked.connect(self.discardROI)
        self.checkBoxPreview.stateChanged.connect(self.checkBoxChangedPreview)
        self.buttonBox.button(QDialogButtonBox.Apply).setEnabled(False)
        self.selectionMadeSource(0)

        self.startSpinBox.setMaximum(self.currentWindow.frames)
        self.endSpinBox.setMaximum(self.currentWindow.frames)
        self.endSpinBox.setValue(self.currentWindow.frames)
        self.checkBoxTimeAll.setChecked(True)
        print('WidgetIsolate ready')

    def closeEvent(self, event):
        """Reimplementation of QWidget.closeEvent

        Parameters
        ----------
        event : PySide2.QtGui.QCloseEvent
            Event when Qt receives a window close request for a top-level widget from the window system
        """
        for roi in self.currentWindow.ROIs:
            roi.setPen(color='54FF00')
        self.checkBoxPreview.setChecked(False)
        event.accept()

    def selectionMadeSource(self, i):
        """Slot for comboBoxSource.currentIndexChanged"""
        print('** selection made in a ', type(self))
        print('* Current source: ', i, ', ', self.comboBoxSource.currentText())
        self.currentWindow = self.windowDict[self.comboBoxSource.currentText()]
        self.currentPlot = self.currentWindow.graphicsView.p1
        self.currentPreps = self.currentWindow.Preps

        self.comboBoxPreps.clear()
        for idx, prep in enumerate(self.currentPreps):
            self.comboBoxPreps.addItem(str(idx) + ': ' + str(prep))
            print('Listing Prep #', idx, ': ', prep)

        self.currentROIs = self.currentWindow.ROIs
        self.comboBoxROIs.clear()
        self.comboBoxROIs.addItem('*New*')
        for idx, roi in enumerate(self.currentROIs):
            self.comboBoxROIs.addItem(str(idx) + ': ' + str(roi.saveState()))
            print('Listing ROI #', idx, ': ', roi)

        print('* Window: ', str(self.currentWindow))
        print('* W x H: ', str(self.currentWindow.width), ' X ', str(self.currentWindow.height))
        print('* Preps: ', str(self.currentPreps))
        print('* ROIs: ', str(self.currentROIs))
        self.loadDefaults()

    def selectionMadePrep(self, i):
        """Slot for comboBoxPreps.currentIndexChanged"""
        print('** selection made in a ', type(self))
        print('* Current Prep: #', i, ': ', self.comboBoxPreps.currentText())
        # for prep in self.currentWindow.Preps:

        index_current = self.comboBoxPreps.currentIndex()
        prep_current = self.currentWindow.Preps[index_current]
        print('* Prep #', index_current, ': ', str(prep_current))

    def selectionMadeROI(self, i):
        """Slot for comboBoxROIs.currentIndexChanged"""
        print('** selection made in a ', type(self))
        print('* Current ROI: #', i, ': ', self.comboBoxROIs.currentText())
        for roi in self.currentWindow.ROIs:
            roi.setPen(color='54FF00')
        index_current = self.comboBoxROIs.currentIndex()
        if index_current > 0:
            # An existing ROI has been selected
            # self.checkBoxPreview.setChecked(False)
            roi_current = self.currentWindow.ROIs[index_current - 1]
            print('* ROI #', index_current - 1, ': ', str(roi_current))
            roi_current.setPen(color='FF000A')
            # self.roi_preview = roi_current
            self.updateParameters(roi_current)
        else:
            # *NEW* has been selected
            self.loadDefaults()

    def loadDefaults(self):
        """Populate ROI parameter inputs with default values"""
        print('* Loading defaults')
        default_r = 15
        # Populate fields with default values
        self.originXLineEdit.setText(str(int(self.currentWindow.width / 2)))
        self.originYLineEdit.setText(str(int(self.currentWindow.height / 2)))
        self.radiusSpinBox.setValue(default_r)

    def updateParameters(self, roi):
        """Populate ROI parameter inputs with an existing ROI's parameters"""
        roi_state = roi.getState()
        x, y = str(int(roi_state['pos'].x())), str(int(roi_state['pos'].y()))
        r = int(roi_state['size'][0])
        # print("Updating roi params with: ", x, ' ', y, ' ', r)
        # Populate fields with passed values
        self.originXLineEdit.setText(x)
        self.originYLineEdit.setText(y)
        self.radiusSpinBox.setValue(r)

    def checkBoxChangedTimeAll(self):
        """Toggle use of all frames of a video for the current ROI"""
        if self.checkBoxTimeAll.isChecked():
            try:
                self.startSpinBox.setValue(1)
                self.startSpinBox.setEnabled(False)
                self.endSpinBox.setValue(self.currentWindow.frames)
                self.endSpinBox.setEnabled(False)
            except Exception:
                traceback.print_exc()
            print('*** UseAll checked')
        else:
            self.startSpinBox.setEnabled(True)
            self.endSpinBox.setEnabled(True)
            print('*** UseAll unchecked')

    def checkBoxChangedPreview(self):
        """Create/destroy preview ROI and read parameter entries"""
        if self.checkBoxPreview.isChecked():
            if not self.roi_preview:
                # Get current ROI values
                x, y = int(self.originXLineEdit.text()), int(self.originYLineEdit.text())
                r = self.radiusSpinBox.value()
                # Create preview ROI if it doesn't exist
                self.roi_preview = pg.CircleROI([x, y], [r, r], pen=(2, 9), scaleSnap=True, translateSnap=True)
                self.roi_preview.setPen(color='FF8700')
                # Draw region on current tiff window's plot
                self.currentPlot.addItem(self.roi_preview)
                self.roi_preview.sigRegionChangeFinished.connect(lambda: self.updateParameters(self.roi_preview))
                self.roi_preview.sigRegionChanged.connect(self.updatePreview)
                self.updatePreview()
            else:
                # ROI Preview exists, update the params
                # Get current ROI values
                x, y = int(self.originXLineEdit.text()), int(self.originYLineEdit.text())
                r = self.radiusSpinBox.value()
                self.roi_preview.setPos((x, y))
                self.roi_preview.setSize(r)
        else:
            # Remove preview ROI
            self.currentPlot.removeItem(self.roi_preview)
            self.roi_preview = None
            self.buttonBox.button(QDialogButtonBox.Apply).setEnabled(False)

    def updatePreview(self):
        """Update ROI preview image in Isolate subwindow"""
        if self.roi_preview:
            # Get current video frame data and preview ROI data
            data_frame = self.currentWindow.video_data[self.currentWindow.frame_current]
            data_preview = self.currentWindow.getRoiPreview(self.roi_preview)

            # self.roi_preview.setParentItem(img_preview)
            # Draw preview data in isolate subwindow
            self.img_preview.setImage(data_preview, levels=(0, data_frame.max()))
            self.v_preview.autoRange()
            self.buttonBox.button(QDialogButtonBox.Apply).setEnabled(True)
        else:
            print('No ROI preview to update!')

    def applyROI(self):
        """Add an ROI to a TIFF or applies changes to an existing ROI"""
        if not self.roi_preview:
            print('No roi_preview to add or edit with')
            return
        else:
            idx_prep = self.comboBoxPreps.currentIndex()
            prepText = self.comboBoxPreps.currentText()
            prepData = self.comboBoxPreps.currentData()
            if not self.checkBoxTimeAll.isChecked():
                frames = self.startSpinBox.text() + '-' + self.endSpinBox.text()
            else:
                frames = None
            if self.comboBoxROIs.currentIndex() is 0:
                # Add the preview ROI to the current TIFF window
                print('*** Applying *NEW* ROI ')
                self.currentWindow.addROI(idx_prep=idx_prep, roi=self.roi_preview, frames=frames)
            else:
                # Set state of the chosen ROI (current list index - 1, due to *NEW* at index 0)
                idx_roi = self.comboBoxROIs.currentIndex() - 1
                print('*** Changing ROI #' + str(idx_roi))
                roi_current = self.currentROIs[idx_roi]
                self.currentWindow.addROI(idx_prep=idx_prep, idx=idx_roi, roi=self.roi_preview, frames=frames)
                roi_current.setPen(color='54FF00')
            self.checkBoxPreview.setChecked(False)
            self.selectionMadeSource(0)

    def discardROI(self):
        """Remove an existing ROI from a TIFF"""
        print('*** Discarding ROI')
        if self.comboBoxROIs.currentIndex() is 0:
            print('Cannot discard *NEW* ROI!')
        else:
            if len(self.currentROIs) < 1:
                print('No ROIs to discard!')
                return
            else:
                idx_roi = self.comboBoxROIs.currentIndex() - 1
                roi_current = self.currentROIs[idx_roi]
                self.currentWindow.removeROI(idx=idx_roi, roi=roi_current)
            self.checkBoxPreview.setChecked(False)
            self.selectionMadeSource(0)


class DesignerSubWindowAnalyze(QWidget, Ui_WidgetAnalyze):
    """Customization for Ui_WidgetAnalyze subwindow for an MDI"""

    def __init__(self, parent=None, w_list=None):
        # initialization of the superclass
        super(DesignerSubWindowAnalyze, self).__init__(parent)
        print('Creating WidgetAnalyze')
        self.windowList = w_list
        self.currentFileName = ''
        self.currentFilePath = ''
        self.windowDict = {}  # Dictionary with structure "window_name_short": "window"
        name_limit = 50
        for w in self.windowList:
            w_name = w.widget().objectName()
            w_name_short = '..' + w_name[-name_limit:] if len(w_name) > name_limit else w_name
            # Populate dictionary
            self.windowDict[w_name_short] = w.widget()
        self.currentWindow = None
        self.currentVideoPlot = None
        self.currentPreps = []
        self.currentROIs = []
        self.currentAnalysis = []
        self.roi_current = None
        self.analysis_preview = None
        self.condition_results = None
        self.peak_results = None
        self.process_results = None

        # setup the GUI
        print('WidgetAnalyze UI setup...')
        self.setupUi(self)
        self.plot_preview = self.widgetPreview.addPlot()
        self.filterCheckBox.stateChanged.connect(self.filterCheckBoxChanged)
        self.tabPeakDetect.setEnabled(False)
        self.tabProcess.setEnabled(False)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)

        self.comboBoxSource.addItems(self.windowDict.keys())
        self.comboBoxSource.currentIndexChanged['int'].connect(self.selectionMadeSource)
        self.comboBoxPreps.currentIndexChanged['int'].connect(self.selectionMadePrep)
        self.comboBoxROIs.currentIndexChanged['int'].connect(self.selectionMadeROI)
        self.comboBoxAnalysis.currentIndexChanged['int'].connect(self.selectionMadeAnalysis)

        self.buttonBoxCondition.button(QDialogButtonBox.Apply).clicked.connect(self.applyCondition)
        self.buttonBoxPeakDetect.button(QDialogButtonBox.Apply).clicked.connect(self.applyPeakDetect)
        self.buttonBoxProcess.button(QDialogButtonBox.Apply).clicked.connect(self.applyProcess)

        self.buttonBoxAnalyze.button(QDialogButtonBox.RestoreDefaults).clicked.connect(self.loadDefaults)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).clicked.connect(self.applyAnalysis)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Discard).clicked.connect(self.discardAnalysis)
        # self.checkBoxPreview.stateChanged.connect(self.checkBoxChangedPreview)
        self.progressBar.setValue(0)
        self.selectionMadeSource(0)
        # self.listWidgetOpenTiffs.addItems(self.windowListNames)
        print('WidgetAnalyze ready')

    def closeEvent(self, event):
        """Reimplementation of QWidget.closeEvent

        Parameters
        ----------
        event : PySide2.QtGui.QCloseEvent
            Event when Qt receives a window close request for a top-level widget from the window system
        """
        for roi in self.currentWindow.ROIs:
            roi.setPen(color='54FF00')
        event.accept()

    def selectionMadeSource(self, i):
        """Slot for comboBoxSource.currentIndexChanged"""
        print('** selection made in a ', type(self))
        print('* Current source: ', self.comboBoxSource.currentText())
        self.currentWindow = self.windowDict[self.comboBoxSource.currentText()]
        self.currentVideoPlot = self.currentWindow.graphicsView.p1
        self.currentPreps = self.currentWindow.Preps
        self.comboBoxPreps.clear()
        for idx, prep in enumerate(self.currentPreps):
            self.comboBoxPreps.addItem(str(idx) + ': ' + str(prep))
            print('Listing Prep #', idx, ': ', prep)

        self.comboBoxROIs.clear()
        self.currentROIs = self.currentWindow.ROIs
        for idx, roi in enumerate(self.currentROIs):
            self.comboBoxROIs.addItem(str(idx) + ': ' + str(roi.saveState()))
            print('Listing ROI #', idx, ': ', roi)

        self.comboBoxAnalysis.clear()
        self.currentAnalysis = self.currentWindow.Analysis
        self.comboBoxAnalysis.addItem('*New*')
        for idx, analysis in enumerate(self.currentAnalysis):
            self.comboBoxAnalysis.addItem(str(idx) + ': ' + str(analysis))
            print('Listing Analysis #', idx, ': ', analysis)

        print('* Window: ', str(self.currentWindow))
        print('* W x H: ', str(self.currentWindow.width), ' X ', str(self.currentWindow.height))
        print('* Preps: ', str(self.currentPreps))
        print('* ROIs: ', str(self.currentROIs))
        print('* Analysis: ', str(self.currentAnalysis))
        # self.loadDefaults()

    def selectionMadePrep(self, i):
        """Slot for comboBoxPreps.currentIndexChanged"""
        try:
            print('*** selection made in a ', type(self))
            print('** Current Prep: ', self.comboBoxPreps.currentText())
            # for prep in self.currentWindow.Preps:

            index_current = self.comboBoxPreps.currentIndex()
            prep_current = self.currentWindow.Preps[index_current]
            print('* Prep: ', str(prep_current))
            # prep_current.setPen(color='FF000A')
            # self.updateParameters(prep_current)
        except Exception:
            traceback.print_exc()

    def selectionMadeROI(self, i):
        """Slot for comboBoxROIs.currentIndexChanged"""
        print('*** selection made in a ', type(self))
        print('** Current ROI: ', self.comboBoxROIs.currentText())
        for roi in self.currentWindow.ROIs:
            roi.setPen(color='54FF00')
        index_current = self.comboBoxROIs.currentIndex()
        # An existing ROI has been selected
        self.roi_current = self.currentWindow.ROIs[index_current]
        print('* ROI: ', str(self.roi_current))
        self.roi_current.setPen(color='FF000A')
        self.progressBar.setValue(20)

    def selectionMadeAnalysis(self, i):
        """Slot for comboBoxAnalysis.currentIndexChanged"""
        print('*** selection made in a ', type(self))
        print('** Current Analysis: ', self.comboBoxAnalysis.currentText())
        index_current = self.comboBoxAnalysis.currentIndex()
        if index_current > 0:
            # An existing Analysis has been selected
            self.analysis_preview = self.currentWindow.Analysis[index_current - 1]
            print('* Analysis #', index_current - 1, ': ', str(self.analysis_preview))
            self.updateParameters(self.analysis_preview)
        else:
            # *NEW* has been selected
            self.loadDefaults()

    def loadDefaults(self):
        """Populate Analysis parameter inputs with default values"""
        # TODO add functionality to Restore Defaults button
        print('** loadDefaults!')
        self.analysis_preview = self.currentWindow.analysis_default.copy()
        self.updateParameters(self.currentWindow.analysis_default)
        if self.tabProcess.isEnabled():
            self.tabProcess.setEnabled(False)
            self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
        if self.tabPeakDetect.isEnabled():
            self.tabPeakDetect.setEnabled(False)
        self.plot_preview.clear()
        self.progressBar.setValue(20)
        self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabCondition)

    def updateParameters(self, analysis):
        """Populate Analysis parameter inputs with an existing Analysis's parameters"""
        print('** Updating Analysis parameters')
        roi = analysis['ROI']
        type = analysis['TYPE']
        roi_calc = analysis['ROI_CALC']
        filter = analysis['FILTER']
        peaks_thresh, peaks_lockout = analysis['PEAKS'].split(',')
        print("* using Analysis parameters: ", roi, ' ', type, ' ', roi_calc, ' ', filter, ' ',
              peaks_thresh, ',', peaks_lockout, ' ', process)

        # Populate fields with passed values
        try:
            self.signalTypeComboBox.setCurrentText(str(type))
            self.roiCalculationComboBox.setCurrentText(roi_calc)
            if pd.isna(filter):
                self.filterCheckBox.setChecked(False)
            else:
                self.filterCheckBox.setChecked(True)
                self.filterFreqSpinBox.setValue(int(filter))
            self.thresholdDoubleSpinBox.setValue(float(peaks_thresh))
            self.lockoutTimeSpinBox.setValue(int(peaks_lockout))
            # self.allResultsCheckBoxVm.setChecked(process == 'ALL')
            # self.allResultsCheckBoxCa.setChecked(process == 'ALL')
        except Exception:
            traceback.print_exc()

    def filterCheckBoxChanged(self):
        """Toggle use of a low pass filter for the current conditioning"""
        if self.filterCheckBox.isChecked():
            self.filterFreqSpinBox.setEnabled(True)
            print('*** Filter checked')
        else:
            self.filterFreqSpinBox.setEnabled(False)
            print('*** Filter unchecked')

    def applyCondition(self):
        """Apply Condition tab selections"""
        # TODO use ROI's frame info
        print('*** Applying Condition, Signal Type:', self.signalTypeComboBox.currentText(),
              ' ROI Calc.:', self.roiCalculationComboBox.currentText())
        self.progressBar.setValue(20)
        try:
            self.analysis_preview['ROI'] = str(self.comboBoxROIs.currentIndex())
            self.analysis_preview['TYPE'] = self.signalTypeComboBox.currentText()
            self.analysis_preview['ROI_CALC'] = self.roiCalculationComboBox.currentText()
            if self.filterCheckBox.isChecked():
                self.analysis_preview['FILTER'] = str(self.filterFreqSpinBox.value())
            else:
                self.analysis_preview['FILTER'] = np.nan
        except Exception:
            traceback.print_exc()
        print('** analysis_preview: ', self.analysis_preview)
        # Calculate conditioned ROI data across all frames
        try:
            print('** ROI_CALC is ', self.analysis_preview['ROI_CALC'])
            if 'Mean' in self.analysis_preview['ROI_CALC']:
                print('* Calculating ROI mean')
                roi_data = self.currentWindow.getRoiStack(self.roi_current)
                roi_data_mean = np.zeros(self.currentWindow.frames)
                for idx, frame in enumerate(roi_data):
                    roi_data_mean[idx] = np.nanmean(frame)
                roi_data_mean_norm = np.copy(roi_data_mean)
                min = roi_data_mean_norm.min()
                max = roi_data_mean_norm.max()
                roi_data_mean_norm = (roi_data_mean_norm - min) / (max - min)
                if 'Voltage' in self.analysis_preview['TYPE']:
                    # TODO Signal type should determine Process tab's results options
                    roi_data_mean_norm = 1 - roi_data_mean_norm
                print('* ROI mean calculated')
                if self.filterCheckBox.isChecked():
                    print('* Filtering ROI mean ')
                    fs = 1 / (self.currentWindow.dt / 1000)
                    Wn = (self.filterFreqSpinBox.value() / (fs / 2))
                    [b, a] = sig.butter(5, Wn)
                    roi_data_mean_norm_filt = sig.filtfilt(b, a, roi_data_mean_norm)
                    print('* ROI mean filtered')
                    self.condition_results = roi_data_mean_norm_filt
                else:
                    self.condition_results = roi_data_mean_norm
            else:
                print('* UNKNOWN ROI_CALC! : ', self.analysis_preview['ROI_CALC'])
            # Plot conditioned signal
            self.plot_preview.plot(self.condition_results, clear=True)
        except Exception:
            traceback.print_exc()

        if self.tabProcess.isEnabled():
            self.tabProcess.setEnabled(False)
            self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
        self.tabPeakDetect.setEnabled(True)
        self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabPeakDetect)
        self.progressBar.setValue(60)
        print('*** Finished Applying Condition')

    def applyPeakDetect(self):
        """Apply Peak Detect tab selections"""
        # Detection Error @ trans#  0  our of  7
        # t0_locs[trans]  70 , up_locs[trans]  72 , peak_locs[trans]  75 , base_locs[trans]  14
        # TODO set y axis to frames, not kframes
        print('*** Applying Peak Detect, Threshold:', self.thresholdDoubleSpinBox.value(),
              ' Lockout Time:', self.lockoutTimeSpinBox.value())
        self.progressBar.setValue(60)
        thresh = self.thresholdDoubleSpinBox.value()
        lockout = self.lockoutTimeSpinBox.value()
        param_peaks = str(thresh) + ',' + str(lockout)
        self.analysis_preview['PEAKS'] = param_peaks
        print('** analysis_preview: ', self.analysis_preview)
        try:
            print('** PEAKS is ', self.analysis_preview['PEAKS'])
            self.peak_results = peak_detect.peak_detect(f=self.condition_results, thresh=thresh, LOT=lockout)
            [num_peaks, t0_locs, up_locs, peak_locs, base_locs, max_vel, peak_thresh] = self.peak_results

            # Redraw conditioned signal
            self.plot_preview.plot(self.condition_results, clear=True)
            # Mark t0_locs, yellow
            self.plot_preview.plot(t0_locs, self.condition_results[t0_locs], pen=None,
                                   symbol='t1', symbolPen=None, symbolSize=10, symbolBrush=(250, 194, 5, 200))
            # Mark up_locs, orange
            self.plot_preview.plot(up_locs, self.condition_results[up_locs], pen=None,
                                   symbol='t1', symbolPen=None, symbolSize=10, symbolBrush=(217, 83, 25, 200))
            # Mark peaks, red
            self.plot_preview.plot(peak_locs, self.condition_results[peak_locs], pen=None,
                                   symbol='t1', symbolPen=None, symbolSize=10, symbolBrush=(255, 5, 5, 200))
            # Mark base_locs, grey
            self.plot_preview.plot(base_locs, self.condition_results[base_locs], pen=None,
                                   symbol='t1', symbolPen=None, symbolSize=10, symbolBrush=(100, 100, 100, 200))
            print('* Peak results (signal, t0_locs, up_locs, peaks, base_locs) plotted')
            # # Mark upstroke
            # for slope in up_locs:
            #     vLine = pg.InfiniteLine(pos=slope, angle=90, movable=False, pen=[100, 255, 100, 80])
            #     self.plot_preview.addItem(vLine)
            #     # Mark the return to baseline
            #     for baseline in base_locs:
            #         if baseline > slope:
            #             vLine = pg.InfiniteLine(pos=baseline, angle=90, movable=False, pen=[100, 255, 100, 80])
            #             self.plot_preview.addItem(vLine)
            #             break
            self.plot_preview.setLabel('left', "Norm. Fluorescence")
            self.plot_preview.setLabel('bottom', "Time", units='frames')
        except Exception:
            traceback.print_exc()

        self.tabProcess.setEnabled(True)
        self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
        self.progressBar.setValue(80)
        self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabProcess)
        print('*** Finished Applying Peak Detect')

    def applyProcess(self):
        """Apply Process tab selections"""
        print('*** Applying Process, All Results')
        self.progressBar.setValue(80)
        [num_peaks, t0_locs, up_locs, peak_locs, base_locs, max_vel, peak_thresh] = self.peak_results
        print('** analysis_preview: ', self.analysis_preview)
        try:
            print('** PROCESS is gone, I am the captain now')
            per_base = 80
            F0 = np.nanmean((self.condition_results[1:t0_locs[0]]))
            if 'Voltage' in self.analysis_preview['TYPE']:
                probe = 1
            else:
                probe = 0
            self.process_results = process.process(self.condition_results, self.currentWindow.dt,
                                                   t0_locs, up_locs, peak_locs, base_locs, max_vel, per_base, F0, probe)
            print('* Results table populated')
            table_model = self.PandasModel(self.process_results)
            self.processTableView.setModel(table_model)
            print('* Process results calculated')
        except Exception:
            traceback.print_exc()
        self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(True)
        self.progressBar.setValue(100)
        print('*** Finished Applying Process')

    def applyAnalysis(self):
        """Add an Analysis to a TIFF or applies changes to an existing Analysis"""
        if not self.analysis_preview:
            print('No analysis_preview to add or edit with')
            return
        else:
            if self.comboBoxAnalysis.currentIndex() is 0:
                print('*** Applying *NEW* Analysis')
                # self.currentWindow.addAnalysis(self.currentWindow.analysis_default)
                self.currentWindow.addAnalysis(analysis=self.analysis_preview)
            else:
                # Set state of the chosen Analysis (current list index - 1, due to *NEW* at index 0)
                idx_analysis = self.comboBoxAnalysis.currentIndex() - 1
                print('*** Changing Analysis #' + str(idx_analysis))
                self.currentWindow.addAnalysis(idx=idx_analysis, analysis=self.analysis_preview)

            if self.tabProcess.isEnabled():
                self.tabProcess.setEnabled(False)
                self.buttonBoxAnalyze.button(QDialogButtonBox.Ok).setEnabled(False)
            if self.tabPeakDetect.isEnabled():
                self.tabPeakDetect.setEnabled(False)
            self.progressBar.setValue(20)
            self.tabWidgetAnalysisSteps.setCurrentWidget(self.tabCondition)
            self.selectionMadeSource(0)

    def discardAnalysis(self):
        """Remove an existing Analysis from a TIFF"""
        # TODO Add functionality to Discard button
        print('*** Discarding Analysis')
        if self.comboBoxAnalysis.currentIndex() is 0:
            print('Cannot discard *NEW* Analysis!')
        else:
            if len(self.currentAnalysis) < 1:
                print('No Analysis to discard!')
                return
            else:
                idx_analysis = self.comboBoxAnalysis.currentIndex() - 1
                analysis_current = self.currentAnalysis[idx_analysis]
                self.currentWindow.removeAnalysis(idx=idx_analysis, roi=analysis_current)
            self.checkBoxPreview.setChecked(False)
            self.selectionMadeSource(0)

    class PandasModel(QtCore.QAbstractTableModel):
        """
        Class to populate a table view with a pandas dataframe
        """

        def __init__(self, data, parent=None):
            QtCore.QAbstractTableModel.__init__(self, parent)
            self._data = data

        def rowCount(self, parent=None):
            return self._data.shape[0]

        def columnCount(self, parent=None):
            return self._data.shape[1]

        def data(self, index, role=QtCore.Qt.DisplayRole):
            if index.isValid():
                if role == QtCore.Qt.DisplayRole:
                    return str(self._data.iloc[index.row(), index.column()])
            return None

        def headerData(self, col, orientation, role):
            if orientation == QtCore.Qt.Horizontal and role == QtCore.Qt.DisplayRole:
                return self._data.columns[col]
            return None


# create the GUI application
app = QApplication(sys.argv)
# instantiate the main window
dmw = DesignerMainWindow()
# show it
dmw.show()
# start the Qt main loop execution, exiting from this script
# with the same return code as the Qt application
sys.exit(app.exec_())
